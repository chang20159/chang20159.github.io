<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解Flexbox弹性盒布局]]></title>
    <url>%2F%E7%90%86%E8%A7%A3Flexbox%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[基本概念 主轴： main axis 主轴起点： main start 主轴终点： main end 交叉轴（侧轴）： cross axis 交叉轴起点： cross start 交叉轴终点： cross end container和item，这两个不翻译最直白，叫容器和项目有点别扭 生成弹性盒 display: flex 生成块盒 inline-flex 生成行内盒 container属性 flex-direction 定义container主轴方向 可选值： row | row-reverse | column | column-reverse 默认值： row flex-wrap 控制container为单行还是多行，定义了侧轴的方向，控制多行时向哪个方向堆砌 可选值：nowrap | wrap | wrap-reverse 默认值：nowrap flex-flow flex-direction 和 flex-wrap的简写，这两个属性加起来就可以控制弹性盒内item的布局流向了 默认值： row nowrap justify-content 设置container内所有item沿主轴上的对齐方式，并分配剩余可用空间。 如果主轴横向，侧轴竖向， justify-content就是控制所有item在横向的位置布局。 可选值：flex-start | flex-end | center | space-around | space-between 默认值： flex-start align-items 设置container内所有item在侧轴上的对齐方式 可选值： flex-start | flex-end | center | baseline | stretch 默认值： stretch item可以通过设置align-self覆盖container的align-items属性 align-content 定义多根轴线之间的对齐方式，并分配剩余可用空间。若没有多根轴线，则不起作用 可选值： flex-start | flex-end | center | space-around | space-between | stretch 默认值： stretch item属性 align-self 设置item在侧轴方向的对齐方式，功能与align-items相同。可覆盖align-items属性。 可选值： auto | flex-start | flex-end | center | baseline | stretch 默认值：auto order 设置item的序数顺序，值越小，越靠前 默认值： 0 flex-grow 设置item的增长因数，不接受负值。 按比例分配剩余空间，没有剩余空间时flex-grow无效 默认值： 0 flex-shrink 设置item的收缩因素，不接受负值 每个item按比例缩小，使总缩小空间为不足的空间，空间足够时flex-shrink无效 默认值：1 flex-basis 设置item伸缩的基准值，不接受负值 默认值： auto 类似于width flex 设置item的尺寸，包括flex-grow、flex-shrink、flex-basis 默认值： 0,1,auto 示例这里看更宽敞&gt;&gt; 应用这里看更宽敞&gt;&gt; 参考 使用弹性盒子进行高级布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端适配实践]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[一般我们在做前端项目之前，都会先拿到视觉稿和交互稿，我们可以根据视觉稿上的尺寸、颜色等信息编写CSS样式，可以根据交互稿来写JS。 每个公司的视觉规范不同，视觉稿也就不同。甚至在一些大公司里，每个部门都有自己的视觉规范。比如页面画布大小是以640为基准还是750。最终给前端开发人员的文件也可能不同，比如psd文件、sketch文件或者图片文件，其中包括页面文件和切图。 我做过的项目里，有这几种情况： sketch文件包 + 总体设计图 + 每个页面图片 + 切图(@2x、@3x各一份) psd源文件 + 总体设计图 + 每个页面图片（有的带尺寸/颜色标注） + 切图(@2x、@3x各一份) 只给带标注的图片的，这种我都会问UED要源文件，标注很难画全的。 我们ued画布基准都是iphone6，但是有的是给的画布宽375的sketch文件，有的给画布宽750的psd文件。 下面以我做过的一个页面为例，左边是sketch文件的截图，右边是psd文件导出的图片。 &nbsp;&nbsp;&nbsp;这个页面涉及到了移动端适配的几个问题:- 布局适配，不同屏幕尺寸的设备中布局一致- 图片高清适配，不同分辨率设备中图片高清展示- 不同分辨率设备中1px边框显示一致- 内容适配，不同屏幕尺寸的设备中的文字大小那，拿到视觉稿了，我们要开始写代码了。假如我们拿到的是宽750的视觉稿在写css代码前还得做件事儿，手机端布局视口默认情况下是768px ~ 1024px之间，手机屏幕宽度大家知道的iphone5 320px, iphone6 375px, iphone6 plus 414px这样子。像下面图示这样，在手机上浏览页面时得横向滚动，是不是很不友好？ 所以我们得想办法，让页面横向内容都展示在屏幕可视范围中，并且禁止缩放。有两种办法： 设置布局视口宽度为一个定值，然后按照布局视口的宽度与屏幕宽度的比例缩放 设置布局视口的宽度 = 设备宽度 设置布局视口宽度为一个定值，按照布局视口的宽度与屏幕宽度的比例缩放 比如屏幕宽375px，视觉稿750px，那就设置布局视口的宽度width=750， scale = 375 / 750 = 0.5 1&lt;meta name="viewport" content="width=750,initial-scale=0.5,maximum-scale=0.5,user-scalable=no"&gt; 再比如屏幕宽320px，视觉稿750px，那就设置布局视口的宽度width=750， scale = 320 / 750 当然这是需要根据屏幕宽度动态设置的: 12345678910111213141516(function()&#123; var doc = window.document; var metaEl = doc.querySelector('meta[name="viewport"]'); if(!metaEl)&#123; metaEl = doc.createElement("meta"); metaEl.setAttribute("name", "viewport"); &#125; var metaCtt = metaEl ? metaEl.content : ''; var matchWidth = metaCtt.match(/width=([^,\s]+)/); var width = matchWidth ? matchWidth[1] : 750 if(width == 'device-width')&#123;return&#125; var screenWidth = window.screen.width; var scale = screenWidth/width; metaEl.setAttribute("content", "width="+ width +",user-scalable=no,initial-scale=" + scale + ",maximum-scale=" + scale + ",minimum-scale=" + scale);&#125;)() demo1 下面是依次在iphone6 plus，iphone6，iphone5上的展示效果。 那有人就会问啦，给的视觉稿是基于iphone5的，画布宽度640怎么办？ 那css编程就按照视觉给的来，width设置640，在宽640的布局视口，CSS样式编写与视觉稿相同，那布局就能与视觉稿相同啦。再通过动态缩放就能把整个页面完整的展示在可视窗口中啦。 那又有人问啦，给的不是750宽的视觉稿，是sketch视觉稿，宽375，这怎么办？ 一样的道理，视觉稿宽375，视觉稿中的元素都是按宽375来布局的，那我们布局视口width设置375，css样式按375的视觉稿来写就好啦，最后就是动态缩放啦。 好啦，那我们来看这种方式能不能解决我们遇到的几个问题。 图片高清问题 实际要解决的是怎么让1个位图像素正好覆盖1个物理像素，这样可以让图片在不同dpr的手机上效果一样。 dpr = 1，需要1倍图 dpr = 2，需要2倍图 dpr = 3，需要3倍图 最好的解决办法是：不同的dpr下，加载不同的尺寸的图片 1px边框问题 实际要解决的是怎么让1个css像素正好覆盖1个物理像素，这样可以让1px边框在不同dpr的手机上一样细。 但是布局视口缩放比为 1/dpr 才能让1个css像素是否正好覆盖1个物理像素。 显然这种按照布局视口的宽度与屏幕宽度的比例缩放的方式，只有与视觉稿画布基准一致的设备才能与视觉稿要求显示的一致。比如这里只有在iphone6上1个css像素是否正好覆盖1个物理像素（横向200px的元素对应400个物理像素，在缩放0.5后，横向200px的元素对应200个物理像素，1:1） 布局适配的问题 其实直接从上面的对比图就可以看出来，在不同设备上布局是一致的。 原理很简单： 我们写CSS本来就是按视觉稿来写的，然后整体缩放，以适应各种宽度的设备，元素的比例没有变。 内容适配的问题 主要是文字大小，因为是整体缩放，屏幕越大，字体也越大。 这个主要看视觉规范怎么定，有的觉得这样挺好，有的就希望字体大小都一样，还有的希望字体大小不是根据屏幕大小按比例缩放而是对一定范围内的屏幕宽度设定特定的字体大小。 总结 【原理】设定布局视口宽度为视觉稿画布宽度，动态设置缩放比例scale=屏幕宽度/视觉稿画布宽度 【优点】实现简单，可解决不同屏幕大小的布局问题，在各种屏幕上布局一致 【缺点】 不能解决1px边框问题； 缩放值依赖于屏幕宽度，demo里是通过screen.width获取屏幕宽度的，这在chrome里iphone6返回的是屏幕宽度值375，但在其他浏览器就不一定了，比如safari中返回的是1280。 所有元素都会缩放，比如字体，在iphone5上就会小很多，这不一定是大家想要的。 设置布局视口的宽度 = 设备宽度1&lt;meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"&gt; 这种情况下有什么效果呢？ demo2 图片太长，横着放了^^ 看看看，都被挤掉了，为啥？这个是iphone6的截图，现在设置了布局视口宽度是屏幕宽度375，我们视觉稿是按iphone6来的宽750，那当然就放不下了，比如视觉稿中图片占位400px x 400px，我们CSS中写的： 1234img&#123; width: 400px; height: 400px;&#125; 但是布局视口宽度就375，图片就放不下了。 那iphone6布局视口宽只有375，我们把视觉稿尺寸全部按比例缩小到375就好啦。那750到375，需要除以2，我们在编写css样式时除以2就好啦。 上面视觉稿中图片是400 x 400，我们CSS中就写： 1234img&#123; width: 200px; height: 200px;&#125; 其他元素的宽高、边框、内边距、外边距、字体大小等，通通先除以2，通通先除以2。那现在的效果是这样的，依次是iphone6 plus，iphone6, iphone5 现在，我们能看到100%呈现在可视窗口中了。那再来看看我们遇到的问题解决了吗？ 1px边框问题 设置0.5px，在dpr=2的设备中对应1个物理像素，在dpr=2的设备中对应1.5个物理像素。 而且在dpr=2的设备中设置0.5px不一定能达到我们想要的效果，看下面： 明明设置的0.5px，但浏览器实际还是按1px处理的。ios7以下，android等其他系统里，0.5px会被当成为0px处理？ 所以直接设置成0.5px是不可行的。 这实际上还是需要1个css像素正好覆盖1个物理像素就可以解决的。 布局适配的问题 因为没有按设备属性动态缩放，每个设备上每个css像素大小都一样，200px大小的元素在每个设备上也够一样长。 其实从上面的对比图就能看出来，图片容器（灰色背景）在不同屏幕大小的手机都是一样的高，整个页面在小屏手机中就需要向下滚动查看，一排展示的4个图片标签在大屏手机中右边的空白就比较大。布局问题也没有解决。 内容适配的问题 文字大小统统一样，也没有解决。 1个css像素只占1个物理像素前面已经讲了几遍了，要解决1px边框的问题，达到在不同分辨率设备上效果一致（当然也与视觉稿一致），需要让不同分辨率设备上 1个css像素只覆盖1个物理像素。 前面我们将750视觉稿中的尺寸除以2来编写样式，只能在iphone6上的效果满足。那现在我们在布局宽度=屏幕宽度时，让缩放比例为 1/dpr，就可以让1个css像素只覆盖1个物理像素。 比如750的视觉稿，元素边框1px，我们CSS样式也写： 123div&#123; border-width: 1px;&#125; 然后js动态设置缩放逻辑大概是这样子： 12345678910111213var doc = document;var docEl = document.documentElement;var isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi);var dpr = window.devicePixelRatio || 1;if (!isIos)&#123; dpr = 1 &#125;var scale = 1 / dpr;var metaEl = doc.querySelector('meta[name="viewport"]');if (!metaEl) &#123; metaEl = doc.createElement("meta"); metaEl.setAttribute("name", "viewport"); doc.head.appendChild(metaEl)&#125;metaEl.setAttribute("content", "width=device-width,user-scalable=no,initial-scale=" + scale + ",maximum-scale=" + scale + ",minimum-scale=" + scale); 那现在无论什么分辨率的设备，1个css像素实际只占1个物理像素了。 那现在效果是什么样子呢？ demo3 所有元素尺寸都缩小1/dpr了，本质上是1个css像素宽度缩小了1/dpr，不同dpr的设备上css像素大小就不同了。那我们css样式200px，在不同dpr的设备上所占宽度也不同了。 注意： 如果在安卓设备上查看demo3，与demo2的效果相同，因为dpr都被处理成dpr=1，没有缩放，css样式又与750视觉稿一致。所以这种方式只缩放，不控制布局视不行的。 这个问题可以在待会讲布局适配时解决，布局适配的目的是让元素在不同设备上占比一致（与视觉稿相同。） 解决布局适配问题可以看下demo3的图 不同屏幕大小的手机都是一样的高，在小屏手机中就需要向下滚动查看。 选择图片标签下一行展示4个，但在大屏手机中右边的空白就比较大。 那我们希望，元素在布局视口中的占比（包括元素宽高、边距等）在不同设备上都相同 同一份样式怎么让元素占比相同呢？用绝对单位px肯定是不行的，我们考虑相对单位rem。 假如有个宽可以表示为20rem的元素： css样式 css像素个数 width:20rem 20 * html元素的font-size 12元素占比 = 元素css像素个数 ／ 布局视口宽度 = 20 * html元素的font-size / 布局视口宽度 所以只要满足： 1常量值 * html元素的font-size = 布局视口宽度 元素占比在任何设备上都是某一个定值了。 那我们只要按下面的公式动态设置html元素的font-size就好啦。 1html元素的font-size = 布局视口宽度 ／ 常量值 这个常量值可以是任意一个常数，但为了写样式方便，我们会做一些考虑，例如： 为了解决前面1px边框retina屏显示的问题，页面缩放了1/dpr，iphone6布局视口的宽度就是：375 * 2 个css像素 我们可以让iphone6中html元素的font-size = 375 * 2 ／ 7.5 = 100，这样可以直接将视觉稿中的尺寸除以100，得到rem单位的数值 对于以iphone6为基准的750视觉稿，并且缩放1/dpr，html元素的font-size 与 布局视口宽度视口的比例可以是: 1html元素的font-size = 布局视口宽度 / 7.5 对于以iphone5为基准的640视觉稿，并且缩放1/dpr 1html元素的font-size = 布局视口宽度 / 6.4 大概的实现就是这样子： 1234567891011121314151617var doc = document;var docEl = document.documentElement;var isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi);var dpr = window.devicePixelRatio || 1;if (!isIos)&#123; dpr = 1 &#125;var scale = 1 / dpr;var metaEl = doc.querySelector('meta[name="viewport"]');if (!metaEl) &#123; metaEl = doc.createElement("meta"); metaEl.setAttribute("name", "viewport"); doc.head.appendChild(metaEl)&#125;metaEl.setAttribute("content", "width=device-width,user-scalable=no,initial-scale=" + scale + ",maximum-scale=" + scale + ",minimum-scale=" + scale);setTimeout(function()&#123; var width = docEl.getBoundingClientRect().width; docEl.style.fontSize = width / 7.5 + 'px';&#125;) 因为scale=1/dpr &amp;&amp; 基于750宽的视觉稿，元素的css样式（rem）可以直接由视觉稿尺寸除以100 最后的效果是： demo4 1html元素的font-size = 布局视口宽度 / 10 demo5 1html元素的font-size = 布局视口宽度 / 7.5 那有人会问啦，我的视觉稿是基于iphone6的，但给的是一倍图宽375怎么办？ 视觉稿一般有两种类型： 一倍图 和 二倍图，比如基于iphone6的： 画布宽750，元素400 x 400画布宽375，元素200 x 200 缩放一般有两种： scale = 1，布局视口宽度 = 375个css像素scale = 1/dpr，布局视口宽度 = 750个css像素 如果视觉稿选择画布宽750，并且scale=1，那元素css像素应该由视觉稿中的尺寸除以2，使布局视口宽度375中400/2 x 400/2 与 视觉稿宽750中400 x 400的元素比例一致 如果视觉稿选择画布宽375，并且scale=1/dpr，那元素css像素应该由视觉稿中的尺寸乘以2，使布局视口宽度750中的元素200x2 x 200x2 与 视觉稿宽375中400 x 400的元素比例一致 其他情况，元素css像素值就是视觉稿中的值。 知道这个之后，再决定px与rem的换算值：html元素的font-size，然后再写css样式（rem）。 举几个例子： 如果视觉稿选择画布宽750，并且scale=1，html元素的font-size = 375 / 7.5 = 50，400／2/50= 4rem 1234img&#123; width: 4rem; height: 4rem;&#125; 如果视觉稿选择画布宽375，并且scale=1/dpr，html元素的font-size = 750 / 7.5 = 100，200 * 2 /100 = 4rem 1234img&#123; width: 4rem; height: 4rem;&#125; 画布宽750 &amp; scale=1/dpr，html元素的font-size = 750 / 7.5 = 100，400 ／ 100 = 4rem 1234img&#123; width: 4rem; height: 4rem;&#125; 画布宽375 &amp; scale=1，html元素的font-size = 375 / 7.5 = 50，200 ／ 50 = 4rem 1234img&#123; width: 4rem; height: 4rem;&#125; 总结 1、 设置html元素的font-size与布局视口宽度成比例，css样式使用相对单位rem，元素尺寸也就与布局视口宽度成比例，从而在每个设备布局一致。用视觉稿来确定这个比例值就能与视觉稿的布局一致。 2、 设置缩放比例为 1/dpr可以解决 1px边框问题。 为了rem与px换算方便，选定的比例值可以让html元素的font-size为100px。iphone6就是7.5，iphone5就是6.4，不同基准的视觉稿rem与px换算比例都是100. 最后，如果不想动态适配的内容，可以直接使用px单位，比如字体，还有1px边框。 淘宝和网易的做法这里讲的适配方案是今天[2017-08-11]的，以后网站方案可能会有改动，所以我把代码保存下来了，可以看适配代码 手机淘宝 网站 适配代码 淘宝统一定为10，iphone6是 1rem = 75px，iphone5 1rem = 64px,可以到手机淘宝验证。不同基准的视觉稿rem与px换算比例不同。 网易 网站 适配代码 并没有做缩放，只使用了相对单位rem。 1html的font-size = 布局视口宽度/7.5 = 设备屏幕宽度 / 7.5 在iphone6上，html的font-size为 375/7.5 = 50px，如果他们的视觉稿是1倍图，那就是直接除以50来写css的，如果是二倍图，就是除以100来写css的。 这个比例可以随便设置，根据实际的需求，网易设置7.5时考虑换算简单，淘宝设置10则是考虑兼容vw。 总结动态修改html元素的font-size和动态修改viewport在很多安卓设备上有兼容性问题。现在越来越多的浏览器支持vw、vh，viewport+rem的方案不一定是最好的方案。 对于1px边框的问题，也有很多其他的解决方案。 判断终端类型是否支持0.5px，支持则直接定义边框为0.5px 使用css定义样式：-webkit-transform: scale(0.5)，对边框进行缩放 使用css实现阴影代替边框：-webkit-box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5) 使用css定义背景样式（background-image）来实现边框 参考 使用Flexible实现手淘H5页面的终端适配 移动端适配方案(上) 移动端适配方案(下) 移动端高清、多屏适配方案 手机百度移动适配切图解决方案介绍 淘宝的flexible适配方案为什么只对iOS进行dpr判断，对于Android始终认为其dpr为1？ Sketch用一倍图做设计稿还是二倍图？ 知乎专栏 DesignCoder]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端web基础]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[单位CSS中的单位相对单位 font-size相关 说明 rem 相对于根元素(html元素)的font-size em 相对于元素的font-size的计算值 ex 相对于元素字体的小写x的高度 ch 相对于元素字体中的字形“0”的宽度 viewport相关 说明 vw 相对于视口宽度 1vw = window.innerWidth * 1% vh 相对于视口高度 1vw = window.innerHeight * 1% vmin vw和vh中较小的值 vmax vw和vh中较大的值 window.innerHeight浏览器窗口的视口（视觉视口）高度（单位：像素，大小是css像素的数量），包括水平滚动条。 window.innerWidth浏览器视口（视觉视口）宽度（单位：像素，大小是css像素的数量），包括垂直滚动条。 绝对单位 px 与设备屏幕相关 对于普通屏幕，通常是显示器的一个设备像素（点） 对于打印机或高分辨率的屏幕，一个CSS像素对应多个设备像素 安卓中的单位 dp 在定义UI布局时使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置 1dp = 160 dpi 屏幕上的1个物理像素 在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI sp px ios中的单位 pt px 参考 安卓多屏支持 CSS Values and Units Level 3 CSS的值和单位 像素（pixel）设备像素（physical pixel） 设备像素又称物理像素（physical pixel），是显示器中最小的物理单元，设备能控制显示的最小单位。 每个像素根据操作系统的指示设置自己的颜色和亮度。 任何设备的物理像素数量都是固定的。 设备独立像素DIP由程序使用并控制的虚拟像素，比如web编程中的CSS像素(px)、安卓（dp）、ios系统(pt)中的设备独立像素. CSS像素CSS像素是Web编程中的概念，浏览器使用的抽象单元。 通常，CSS像素被称为与设备无关的像素（DIP）。在标准密度显示器上，1个CSS像素对应于1个设备像素。 例如： 1&lt;div height="200" width="300"&gt;&lt;/div&gt; 在普通屏幕上绘制200x300设备像素，在retina显示屏上为保证相同的物理尺寸，相同的div将使用400x600设备像素，这样在Retina显示屏上，相同物理表面的设备像素数量是普通显示屏的四倍。 设备像素与设备独立像素设备像素与设备独立像素有一定的对应关系，我们编程时控制的是设备独立像素，然后由相关系统转换为物理像素。 一个CSS像素相当于多少个设备像素由屏幕特性（是否是高密度）和缩放比例决定。放大得越大，一个CSS像素覆盖的设备像素越多。 分辨率 显示器能显示的物理像素的数量，显示器可显示的像素越多，画面就越精细。 屏幕像素密度(Screen density)屏幕像素密度是指物理表面的像素数量，通常以每英寸像素测量（PPI，pixel per inch）。ppi的值越高，画质越好。 苹果公司为其双重密度显示器创造了“Retina”营销术语，声称人眼不再能够将屏幕上的各个像素与“自然”观看距离区分开来。 要计算显示器的屏幕像素密度（每英寸像素值），首先要确定屏幕尺寸和分辨率。 例如，苹果的iphone6s，像素分辨率： 1334 x 750，对角线长度4.7英寸。 那屏幕像素密度就是：苹果公司认为，人类能肉眼识别的最高像素密度是300ppi 现在也有越来越多高分辨率的安卓手机（显示屏）与苹果iPhone的视网膜显示器相同。根据屏幕每英寸像素值的不同，Android系统的开发者将平板电脑和手机的屏幕分成五类： 名称 显示等级 每英寸像素值 相似ppi的ios设备分类 LDPI @0.75x 低等像素密度 大约120ppi MDPI @1x 中等像素密度 大约160ppi 标准点@1x HDPI @1.5x 高等像素密度 大约180ppi XHDPI @2x 极高像素密度 大约320ppi 视网膜 @2x XXHDPI @3x 超高像素密度 大约480ppi 高清视网膜 @3x 设备像素比dpr 缩放比为1时的物理像素分辨率与CSS像素分辨率的比值 在js中可以通过 window.devicePixelRatio获取，也可以重写window.devicePixelRatio来更改dpr css中可以使用媒体查询 device-pixel-ratio 位图像素（Bitmap Pixel）位图像素是基于栅格的图像（JPG、PNG、GIF）中最小的单位，每个像素都包含屏幕上的显示信息，如位置、颜色等，有的图像信息还包含不透明度（Alpha Channel）。 位图图像除了自有的光栅分辨率，在web网页中有一个用CSS像素定义的抽象尺寸，web浏览器根据CSS设置的高度和宽度属性在屏幕上绘制基于栅格的图像，根据CSS尺寸可能会挤压或拉伸图像。 当在标准密度显示器上以完整尺寸绘制光栅图像时，1个位图像素对应1个设备像素，图像完全保真显示。因为位图像素不能进一步分割，在retina显示屏中，位图像素应该是标准屏上的4倍才能保真高清显示。 通常为Retina屏提供图像的方法是通过使用HTML或CSS编程手段将图像容器尺寸减半。 例如，要展示 200 x 300像素的图像（这是css像素），可以向服务器请求位图分辨率为400 x 600像素（4倍）的图像。 1&lt;img src="https://img.meituan.net/beautyimg/0e03672ea40f4f692f193349b86aeb90299167.jpg%40400w_600h_1e_1c_1l_100q%7Cwatermark%3D0"/&gt; 1234img&#123; width:200px; height: 300px;&#125; 这在标准密度显示器上，有一个下采样的过程。对于位图像素400x600的图像，要在200 x 300的设备像素上展示，需要对其进行2倍下采样，得到（400/2）x（600/2）的分辨率图像。那其实就是把 2 x 2窗口内的位图像素变成一个像素，这个像素点的值就是窗口内所有像素的均值。 图像下采样原理 对于一幅图像I尺寸为MN，对其进行s倍下采样，即得到(M/s)(N/s)尺寸的得分辨率图像，当然s应该是M和N的公约数才行，如果考虑的是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素。 这个像素点的值就是窗口内所有像素的均值: pk&#xA0;=&#xA0;&#x2211;i&#x2208;win(k)Ii&#xA0;/&#xA0;s2 图像上采样原理 图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。 为了在Retina显示屏上能够高清保真显示图像，需要加载2倍图像。但对于标准显示屏设备，如果同样使用2倍图像，会有几个问题： 需要下载更大的图片资源，造成资源浪费 根据所使用的下采样算法，2倍图像在标准密度屏幕上会丢失一些锐度 这就是如何在移动端不同分辨率设备中图片高清保真显示的问题，不同屏幕密度的设备应该加载不同大小的图像，保证在不同设备上都能保真显示。 移动端图片高清显示问题CSS媒体查询与background-image配合使用可以通过媒体查询的方式，对不同dpr设备使用不同分辨率的图像。 123456789101112131415.icon &#123; background-image: url(example.png); background-size: 200px 300px; height: 300px; width: 200px;&#125;@media only screen and (-Webkit-min-device-pixel-ratio: 1.5),only screen and (-moz-min-device-pixel-ratio: 1.5),only screen and (-o-min-device-pixel-ratio: 3/2),only screen and (min-device-pixel-ratio: 1.5) &#123; .icon &#123; background-image: url(example@2x.png); &#125;&#125; dpr查询使用1.5而不是2，可以用相同的语句来查询其他非Apple设备。这种方式主要用于使用background-image属性显示的图像。 优点 设备仅下载合适的目标资源 跨浏览器兼容 像素精确控制 缺点 编程代码繁琐，特别是在大型网站上 对于内容展示型图像显示为其他HTML元素的背景，这在语义上是不正确的 js控制加载合适尺寸的图像可以使用window.devicePixelRatio在Javascript中查询dpr，比CSS更容易设置图像。 然而，由于使用JavaScript，渲染可能会延迟。 1234567891011$(document).ready(function()&#123; if (window.devicePixelRatio &gt; 1) &#123; var images = $('img'); images.each(function(i) &#123; var lowres = $(this).attr('src'); var highres = lowres.replace(".", "@2x."); $(this).attr('src', highres); &#125;); &#125;&#125;); 这种方式比较适合展示内容型图像。 优点 易于实现 非Retina设备不需要下载大的图片资源 像素精确控制 缺点 Retina设备必须下载1倍图和2倍图 图像替换效果在Retina设备上能体现 window.devicePixelRatio不支持IE或Firefox。 其他方案 可缩放矢量图形SVG 不管使用什么方法，光栅图像都会被位图分辨率限制，不是无限可扩展的。但矢量图形无限缩放都不会影响清晰度 1&lt;img src="sample.svg" width="300" height="200" /&gt; 字体图标 Icon Fonts 参考 维基百科-每英寸像素 每英寸点数 devicePixelRatio浏览器兼容性 Towards A Retina Web 图像缩放 MathML公式编辑器 视口在桌面浏览器中只有一个视口，视口的宽度 = 浏览器窗口宽度。在小屏的移动设备（宽度240px～640px）中，如果视口宽度和浏览器宽度一样，那为桌面浏览器设计的网页在移动端查看时会很丑，所以移动端浏览器厂商会设置一个默认的移动设备的视口宽度，在768px ~ 1024px之间，最常见的宽度是980px。 布局视口 CSS的布局将根据上面介绍的视口来计算，所以在移动端这就叫布局视口。 视觉视口虽然移动端默认的布局视口宽度可以让为桌面浏览器设计的网页很好的展示，但只会有一部分内容展示在可视区域，这个区域被称为视觉视口。用户可以通过缩放来操作视觉视口。 理想视口 对于移动端网页，默认的布局视口的宽度并不是一个理想的宽度，我们不希望需要通过缩放查看内容，所以浏览器厂商引进了理想视口的概念，与理想视口宽度相同的网页是最理想的用户浏览的宽度，刚进入页面时用户不需要缩放。 那对于移动端网页，我们需要设置布局视口的宽度为理想视口的宽度。这需要在meta标签中声明： 1&lt;meta name="viewport" content="width=device-width"/&gt; 参考 移动web手册 meta标签上面提到了通过meta标签声明布局视口的宽度。meta标签的常用属性： 属性 可选值 描述 charset UTF-8等 声明当前文档所使用的字符编码 name author、description 、keywords、 viewport等 把 content 属性关联到一个名称 http-equiv content-type 、expire 、refresh 、set-cookie 把content属性关联到HTTP头部 content name属性相关的元信息，格式：key=value 定义与http-equiv或name属性相关的元信息 对于viewport元标签格式： 1&lt;meta name="viewport" content="key=value, key=value"/&gt; 其中content内容： width：布局视口宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素） height：布局视口高度（数值 / device-height）（范围从223 到10,000） initial-scale：初始的缩放比例 （范围从&gt;0 到10） minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩 (no,yes) 对于移动端页面，常将布局视口宽度设置为理想视口宽度，并禁止缩放： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/&gt; 参考 MDN meta标签 媒体查询媒体查询类型 媒介类型查询 视口相关 特性相关 语法 123@media 媒体类型 and (视口特性阀值)&#123; // 满足条件的css样式代码&#125; 媒体查询示例 1234567891011121314.sample &#123; background-image: url(sample.png); width: 300px; height: 200px;&#125; @media only screen and (-Webkit-min-device-pixel-ratio: 1.5), only screen and (-moz-min-device-pixel-ratio: 1.5), only screen and (-o-min-device-pixel-ratio: 3/2), only screen and (min-device-pixel-ratio: 1.5) &#123; .sample &#123; background-image: url(sample@2x.png); &#125;&#125; 更多用法参考 W3C关于媒体查询的介绍 W3C 媒体查询标准]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片预加载和懒加载]]></title>
    <url>%2F%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[预加载和懒加载是两种加载资源的方式，适用于不同场景。常见的是图片的预加载和懒加载，最近开发组件库，图片组件就用到了预加载和懒加载，记录一下实现方式和相关知识点。 预加载预加载就是预先加载资源，在使用时就不需要再加载。比如预先加载图片，显示图片时直接从缓存读取不需要再发出网络请求了。 那预加载是怎么实现的呢？我们可以使用Image元素构造器。 12let image = new Image()image.src = 'https://www.dpfile.com/sc/ares_pics/f6f4d77d040d9a0ab77e94059d1772c8.png' 在使用图片之前，创建一个Image实例，并给实例的src实行赋值就可以请求图片。 我们还可以使用纯CSS或者Ajax实现预加载。 预加载的好处是提前加载，用户操作过程中响应更快。但是在一些场景下会牺牲服务器性能或浪费用户流量。比如一屏的图片很多，如果全部加载完，用户不一定能看得到，一次性耗费流量大而且首次等待时间较长。 这时候我们就可以用懒加载~~~ 懒加载懒加载，就是延迟加载的意思。 常见的一个场景就是，图片开始进入屏幕范围才加载。实现的原理是，预先给一个默认图片，当图片进入窗口可视范围时，再将src属性替换。 那什么时候图片开始进入屏幕呢？我们可以通过这三者来计算： 窗口顶部与文档顶部之间的距离（scrollTop） 可视窗口的高度（clientheight） 图片与文档顶部的距离(offsetTop) 计算屏幕可视窗口大小 window.innerHeight 标准浏览器及IE9+ document.documentElement.clientHeight 标准浏览器及低版本IE标准模式 document.body.clientHeight 低版本混杂模式 123function getClientHeight()&#123; return window.innerHeight ? window.innerHeight : document.compatMode === 'BackCompat' ? document.body.clientHeight : document.documentElement.clientHeight&#125; 计算顶部与文档顶部之间的距离 window.pageYOffset 标准浏览器及IE9+ document.documentElement.scrollTop 兼容ie低版本的标准模式 document.body.scrollTop 兼容混杂模式 123function getBodyScrollTop()&#123; return window.pageYOffset ? window.pageYOffset : document.compatMode === 'BackCompat' ? document.body.scrollTop : document.documentElement.scrollTop&#125; 计算图片与文档顶部的距离 可以通过offsetTop来计算 MDN上对于offsetTop的定义：返回当前元素相对于其 offsetParent 元素的顶部的距离。 HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table cell 元素对象或根元素（标准模式下为 html；quirks 模式下为 body）。当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。 所以图片与文档顶部的距离可以这样计算： 12345678910function getOffsetTop(elem) &#123; let offsetTop = 0 if (elem.offsetParent) &#123; do &#123; offsetTop += elem.offsetTop elem = elem.offsetParent &#125; while (elem) &#125; return offsetTop &gt;= 0 ? offsetTop : 0&#125; 懒加载的实现： 当 bodyScrollTop + bodyHeight &gt;= imageTop时加载图片 123456789101112131415161718192021222324252627lazyLoadImage()&#123; this.scrollTop = getBodyScrollTop() this.bodyHeight = getClientHeight() this.imageTop = getOffsetTop(this.$refs.imageParentRef) if(!this.load &amp;&amp; (this.scrollTop + this.bodyHeight &gt;= this.imageTop))&#123; this.loadImage() &#125;&#125;loadImage()&#123; try&#123; let img = new Image() img.src = this.src this.load = true if(img.complete)&#123; this.handleLoadSuccess(img) return &#125; img.onload = ()=&gt;&#123; img.onload = null this.handleLoadSuccess(img) &#125; &#125;catch(err)&#123; this.$emit('load',err) &#125;&#125; 当图片滚动到刚进入视图时，才会加载。但是可能由于网络速度较慢等原因，图片滚动到可视区域内时都没有加载完毕，会出现闪屏。 为了更好的用户体验，我们可以在用户再滚动半屏就能看到图片的位置就加载图片，加载的条件判断可以改成： 1this.scrollTop + this.bodyHeight + this.bodyHeight/2 &gt;= this.imageTop 另外，在加载图片完成后会触发onload事件，但img加载完成就会解除onload事件，src是异步加载图片的，如果在绑定事件前就已经加载完成，onload事件不会触发，这时可以先用img.complete属性判断。 complete 属性可返回浏览器是否已完成对图像的加载，如果加载完成，则返回 true，否则返回fasle。 在图片加载完成后，就可以在handleLoadSuccess方法中获取图片宽高，设置图片的显示方式了。 注意： 懒加载图片应该先预加载默认图片(俗称：占位图)，用于计算图片位置。]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue组件开发常见问题及技巧]]></title>
    <url>%2FVue%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Vue组件库开发，记录过程中的问题和经验。 手机端Vue组件库，戳&gt; Swan UI 一、props检测设定任意类型设置为null 123props: &#123; title: null&#125; 二、组件外部传入class无法覆盖组件内部动态class当给自定义组件添加class时，组件根元素上class的顺序是： inner-class（内部class） outer-class(外部传入class) inner-dynamic-class(内部动态计算class) 使用组件： 1&lt;sw-button class="outer-class"&gt;按钮&lt;/sw-button&gt; 组件内部结构： 123&lt;button class="inner-class" :class="&#123;'inner-dynamic-class':true&#125;"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/button&gt; 最终结构： 123&lt;button class="inner-class outer-class inner-dynamic-class" &gt; 按钮 &lt;/button&gt; 对于需要修改组件样式的使用方，外部传入组件的class属性 outer-class 始终在内部动态属性之前，无法覆盖内部属性 解决办法是：组件外部也是用动态class 1&lt;sw-button :class="&#123;'outer-class':true&#125;"&gt;按钮&lt;/sw-button&gt; 三、样式文件中引入npm安装包报错Module not found: Error: Can’t resolve ‘./phoenix-styles/less/public.less’ in ‘/Users/chang/future-team/swan-ui/src/modules’ @ ./~/css-loader!./~/vue-loader/lib/style-compiler?{“vue”:true,”id”:”data-v-e577e6cc”,”scoped”:false,”hasInlineConfig”:false}!./~/vue-loader/lib/selector.js?type=styles&amp;index=0!./src/modules/Input.vue 3:10-95 *.vue文件中引入npm安装包: 1&lt;style lang="less" src="phoenix-styles/less/public.less"&gt;&lt;/style&gt; 四、class属性不能作为组件的prop “class” is a reserved attribute and cannot be used as component prop. 我想拿到传给组件的class，不想让他直接添加到组件根元素上肿么破？ Vue handles passing the class attribute through automatically - I think you can just delete the entire object and prop declaration and it will continue working fine. 五、将属性合并赋值利用v-bind可以直接赋值对象 123456789&lt;template&gt; &lt;label class="ph-multi-group"&gt; &lt;div :class="`ph-$&#123;type&#125;`"&gt; &lt;input v-bind="nativeProps" @change="handleChange"/&gt; &lt;i&gt;&lt;/i&gt; &lt;/div&gt; &lt;span&gt;&#123;&#123;label&#125;&#125;&lt;/span&gt; &lt;/label&gt;&lt;/template&gt; 六、 在vue的render方法中使用JSXbabel配置文件.babelrc添加插件 transform-vue-jsx 1234&#123; "presets": [["es2015", &#123; "loose": false &#125;]], "plugins": ["transform-vue-jsx"]&#125; 安装插件 1npm install --save-dev babel-plugin-transform-vue-jsx 七、自定义 v-model + mixins隐藏/显示类组件采用双向绑定，避免书写关闭打开等样板代码。 12345678910111213141516171819202122232425/** * 定制隐藏/显示切换类组件的 v-model */export default &#123; model: &#123; prop: 'visible', event: 'toggle' &#125;, methods: &#123; handleToggle(val)&#123; this.$emit('toggle',val) &#125; &#125;, props: &#123; /** * 是否可见标识 * @property visible * @type Boolean * */ visible: &#123; type: Boolean, default: false &#125; &#125;&#125; 八、声明组件props时，同时声明组件内部使用的其他组件的props123&lt;template&gt; &lt;sw-checkbox v-bind="$props" @change="handleChange" /&gt;&lt;/template&gt; 123456789101112131415161718&lt;script&gt; import SwCheckbox from '../checkbox/Checkbox.vue' export default &#123; name: 'SwRadio', components: &#123;SwCheckbox&#125;, methods: &#123; handleChange(value,evt)&#123; this.$emit('change',value,evt) &#125; &#125;, props: Object.assign(&#123;&#125;,SwCheckbox.props,&#123; type: &#123; type: String, default: 'radio' &#125; &#125;) &#125;&lt;/script&gt; 注意： 2.4.0版本新增了 inheritAttrs选项和实例属性$attrs，可以这样写了： 12345&lt;template&gt; &lt;sw-checkbox :type="type" v-bind="$attrs" @change="handleChange" /&gt;&lt;/template&gt; 12345678910111213141516171819&lt;script&gt; import SwCheckbox from '../checkbox/Checkbox.vue' export default &#123; name: 'SwRadio', inheritAttrs: false, components: &#123;SwCheckbox&#125;, methods: &#123; handleChange(value,evt)&#123; this.$emit('change',value,evt) &#125; &#125;, props: &#123; type: &#123; type: String, default: 'radio' &#125; &#125; &#125;&lt;/script&gt; 九、双向watch或双向computed解决使用v-model的问题例如使用dialog组件： 123&lt;sw-dialog title="提示" v-model="visible"&gt; 您确定以及肯定要提交吗？&lt;/sw-dialog&gt; 当另一个组件Alert使用dialog组件时： 12345&lt;template&gt; &lt;sw-dialog title="提示" v-model="visible"&gt; &#123;&#123;content&#125;&#125; &lt;/sw-dialog&gt;&lt;/template&gt; 那如果我们要使用Alert组件: 1&lt;sw-alert title="提示" v-model="visible" content="您确定以及肯定要提交吗？" /&gt; 由于内部dialog组件使用双向绑定，弹框关闭时，visible属性会被直接更改，不能通知sw-alert。这种情况在使用数据管理框架例如vuex时也可能出现。 那我们可以添加一个中间属性，使用双向watch或双向computed来解决。 在alert组件组件中双向watch： 1&lt;sw-alert title="提示" v-model="currentVisible" content="您确定以及肯定要提交吗？" /&gt; 123456789101112model: &#123; prop: 'visible', event: 'toggle'&#125;watch: &#123; visible(val)&#123; this.currentVisible = val &#125;, currentVisible(val)&#123; this.$emit('toggle',val) &#125;&#125; 或者双向computed(这个没有具体实施，应该是可以的): 12345678910111213model: &#123; prop: 'visible', event: 'toggle'&#125;computed: &#123; visible()&#123; this.$emit('toggle',this.currentVisible) return this.currentVisible &#125;, currentVisible()&#123; return this.visible &#125;&#125; 十、props属性不需要声明也可以使用 2.4.0版本之前，父作用域传递的属性，在props中声明才可以使用，这对类似Input之类的组件扩展性不好，需要把input属性都声明出来，有点啰嗦。 vue 2.4.0新增的inheritAttrs选项和实例属性$attrs， 可以解决这个问题啦～ inheritAttrs选项: 默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。 当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 实例属性$attrs: 包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 props 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建更高层次的组件时非常有用。 之前对于Input组件，我需要声明尽可能多的常用的input的原生属性，并手动分离出来添加到input标签上： 1&lt;input v-bind="nativeProps"/&gt; 12345678910111213141516171819202122232425262728computed: &#123; nativeProps()&#123; let props = ['name','maxlength','minlength','disabled','autocomplete','autofocus','min','max','readonly'] let nativeProps = &#123;&#125; props.forEach((key)=&gt;&#123; if(this.$props[key])&#123; nativeProps[key] = this.$props[key] &#125; &#125;) return nativeProps &#125;&#125;,props:&#123; visible: Boolean, clear: Boolean, //以下是input原生属性 placeholder: String, disabled: Boolean, maxlength: Number, minlength: Number, autocomplete: String, autofocus: Boolean, readonly:Boolean, value: null, name: null, min:null, max:null&#125; 现在可以这样写了： 1&lt;input v-bind="$attrs"/&gt; 12345inheritAttrs: false,props: &#123; visible: Boolean, clear: Boolean&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[要做一个合格的前端攻城狮]]></title>
    <url>%2F%E8%A6%81%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%88%E6%A0%BC%E7%9A%84%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9F%8E%E7%8B%AE%2F</url>
    <content type="text"><![CDATA[HTML、CSS、JS、移动端开发、缓存、web安全、浏览器工作原理、前端框架、Hybrid技术、设计模式、前端构建工具…这些你都懂吗？ HTML HTML 开发者指南 CSS 谈谈一些有趣的CSS题目 flex布局 深入了解 Flexbox 伸缩盒模型 CSS 伸缩盒布局模组 理解BFC IFC 居中方案 两栏/三栏自适应布局 CSS预处理 Less Sass Less VS Sass JS 闭包 this 对象模型的细节 继承与原型链 JavaScript Promise：简介 史上最易读懂的 Promise 实现 内存管理 移动端开发移动端适配 移动web基础知识 移动端适配实践 移动端兼容性 ios和android 浏览器适配问题总结 移动web资源整理 网络web通信 Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE Ajax长轮询、Ajax轮询、iframe长轮询、SSE、websoket通信 Demo 缓存 大公司里怎样开发和部署前端代码？ max-age=0、no-cache、no-store区别? Web安全 Web Security 网站常见攻击手段 1、跨站请求伪造CSRF CSRF 攻击的应对之道 预防CSRF攻击 2、跨站脚本攻击XSS 避免XSS攻击 MDN-跨站脚本攻击 Web 安全编程实战 新浪微博遭受XSS跨站脚本攻击实例分析 SQL注入 安全策略 同源策略 浏览器的同源策略 HTTP访问控制（CORS） Server-Side Access Control Web开发中跨域的几种解决方案 数据过滤 确保输入过滤 HTTPS 安全加密 Cookie 聊一聊 cookie 浏览器工作原理 浏览器的工作原理：新式网络浏览器幕后揭秘 Webkit技术内幕 框架/库React React中文文档 深入浅出React（一）：React的设计哲学 - 简单之美 深入浅出React（二）：React开发神器Webpack 深入浅出React（三）：理解JSX和组件 深入浅出React（四）：虚拟DOM Diff算法解析 深入浅出React（五）：使用Flux搭建React应用程序架构 Immutable Redux Flux框架对比 vue vue中文官网 vue-loader Vue.js 服务器端渲染指南 vue-router Vue组件开发常见问题及技巧 jQuery模块开发规范规范 AMD CMD COMMON JS模块化编程之加载器原理相对应的类库？ requirejs原理 模块管理与打包实践 Hybrid技术设计模式 单例模式 观察者 组合 mvc mvvm SPA 【技术方案】单页应用 ES6／ES7／ES8特性性能优化 Exceptional Performance Best Practices for Speeding Up Your Web Site（雅虎35条） 学习渠道 慕课网 MDN 懂点设计其他 为什么Github没有记录你的Contributions]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[给Hexo+Github page博客绑定域名的一些问题]]></title>
    <url>%2F%E7%BB%99hexo%2Bgithubpage%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[项目终于做完了，忽然想到买了很久的域名一直没有用，本来以为还要备案啥的，就一直没倒腾。今天研究了下域名绑定，居然很快就弄好了。但是也遇到了几个问题，还是记录一下吧~ 升级Node.js后，执行hexo generate报错 Hexo博客绑定域名 CNAME文件问题 个人主页添加域名后项目主页访问不了了 升级Node.js后，执行hexo generate报错12345Error: The module &apos;/usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 48. This version of Node.js requiresNODE_MODULE_VERSION 51. Please try re-compiling or re-installingthe module (for instance, using npm rebuild ornpm install). 重新安装 hexo-cli 1npm install -g hexo-cli 或者 1cnpm install -g hexo-cli 如果提示没有权限，再加上sudo。然后删除node_modules 再重新 npm install 国内hexo好像都得cnpm Hexo博客绑定域名使用的github page，绑定域名过程如下： 1、在阿里云购买域名 戳链接 恩，chang20159.com 这个域名我买下了 2、准备好github项目的机器IP 终端执行 ping chang20159.github.io 1234&gt;ping chang20159.github.ioPING github.map.fastly.net (151.101.72.133): 56 data bytes64 bytes from 151.101.72.133: icmp_seq=0 ttl=50 time=90.449 ms64 bytes from 151.101.72.133: icmp_seq=1 ttl=50 time=91.037 ms 拿到github项目的机器IP 151.101.72.133 3、绑定域名 要把域名chang20159.com 与 github page项目 chang20159.github.io绑定 域名买好了之后，在控制台找到域名的入口，就可以看到这个，添加了主机记录@和www 这样我们就可以访问 chang20159.com 和 www.chang20159.com 了 点击域名&gt;域名解析&gt;新手引导设置 按步骤绑定，绑定好了就能看到下面这个 现在还不能访问chang20159.com，还有一步4、 添加CNAME文件在chang20159.github.io项目中添加CNAME文件，文件没有后缀名，文件内容是： 1chang20159.com CNAME文件要添加到hexo项目的source目录下，在github项目的setting里面有个Custom domain选项，如果在那里添加cname也可以，但是hexo项目不行，因为如果source目录下没有cname文件的话每次deploy后那个设置又没有了。 个人主页添加域名后项目主页访问不了了github上还有个项目sharing，本来没有cname，通过chang20159.github.io/sharing可以直接访问这个项目的，但是个人主页项目cname后项目主页就404了。 因为 访问 chang20159.github.io/sharing 会跳转到 chang20159.com/sharing ,但是chang20159.github.io项目是没有sharing文件的，所以就404了。 问题有了，办法也是有的。 1、 在sharing这个项目中也添加CNAME文件文件内容是： 1sharing.chang20159.com 2、 在阿里云域名管理页面chang20159.com下添加一个记录就是下面这样：这样就可以通过sharing.chang20159.com 访问 sharing项目的内容了。 这样 访问sharing.chang20159.com 就能与机器151.101.72.133连接，然后通过cname找到sharing项目了]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解BFC]]></title>
    <url>%2F%E7%90%86%E8%A7%A3BFC%2F</url>
    <content type="text"><![CDATA[网上有太多关于BFC的文章，看了很多，还是不能理解。想想还是看全英文的官方文档，关于BFC的规则，在w3c文档中的第9章和第10章全局搜一下Block formatting context，就能找到。 什么是BFCCSS中每个元素都会根据盒模型生成0个或多个Box，Box是布局的对象和基本单位，Visual formatting model描述了一套规则，决定元素如何对其内容进行布局，以及与其他元素的关系和作用。盒布局由以下几个方面组成： 盒的尺寸和类型（明确指定、受限或没有指定 行内级盒、块级盒） 盒布局方案（常规流、浮动、绝对定位） 文档树中元素之间的关系 其他 如视口、图片大小等 对于浮动布局，由float属性决定对于绝对定位布局，由position属性决定而对于常规流的布局，则与display属性有很大关系 根据display属性的计算值，可以将box分为块级盒和行内级盒 块级盒 display的计算值 为 block, list-item 或 table 行内级盒 display的计算值为 inline, inline-block 或 inline-table 在常规流中，不同的Box会参与不同formatting context（在这个格式化上下文中有一套渲染规则），block-level box（块级盒）参与block formatting context（BFC）中的规则，inline-level box（行内级盒）参与 inline formatting context(IFC)中的规则。 我们常常会让一个元素生成block formatting context（BFC），在这个block formatting context中的块级盒都遵循一套布局规则，下面会讲怎样让一个元素生成BFC以及块级盒在BFC中会遵循哪些规则 哪些元素会触发BFC官方文档是这样说的 Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. 解释一下就是，以下这些元素可以生成BFC,其内部块级盒按照BFC的规则布局 浮动元素 float非none 绝对定位元素 position为absolute和fixed diplay属性为：inline-block | table-cell | table-caption等非块盒 overflow属性是非visible值 一般情况下，都是使用overflow:hidden来触发BFC，对元素内部布局影响比较小，也不会影响其他元素 BFC规则官方文档是这样说的： In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). The border box of a table, a block-level replaced element, or an element in the normal flow that establishes a new block formatting context (such as an element with ‘overflow’ other than ‘visible’) must not overlap the margin box of any floats in the same block formatting context as the element itself. But in CSS 2.1, if, within the block formatting context, there is an in-flow negative vertical margin such that the float’s position is above the position it would be at were all such negative margins set to zero, the position of the float is undefined. 10.6.7 ‘Auto’ heights for block formatting context rootsIn certain cases (see, e.g., sections 10.6.4 and 10.6.6 above), the height of an element that establishes a block formatting context is computed as follows: If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box. If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level child box and the bottom margin-edge of the bottommost block-level child box. Absolutely positioned children are ignored, and relatively positioned boxes are considered without their offset. Note that the child box may be an anonymous block box. In addition, if the element has any floating descendants whose bottom margin edge is below the element’s bottom content edge, then the height is increased to include those edges. Only floats that participate in this block formatting context are taken into account, e.g., floats inside absolutely positioned descendants or other floats are not. 按照顺序来解释一下BFC规则就是这些1、从包含块顶部开始，内部的box一个接一个垂直排列2、两相邻box在垂直方向的距离由margin决定，属于同一个BFC的相邻box的margin会发生重叠collapse3、在同一个BFC中，每个box的左外边缘（margin边界）与包含块的左边缘(border内边界)接触（对于从右至左排列的布局则相反）;这对于浮动元素也一样4、常规流中一个建立块格式化上下文的元素（触发BFC的元素）不会和任何浮动元素的外边界框重叠5、没明白啥意思 囧6、关于BFC中元素高度的计算 在某些情况下，建立块格式化上下文的元素的高度是这样计算的： 如果它只有行内级child box，它的高度就是最上面的线框的顶部和最下面的线框的底部之间的距离； 如果它有块级child box，它的高度就是最上面块child box的上外边界（margin-top）与最下面块child box的下外边界（margin-bottom）之间的距离； 绝对定位的child box会被忽略，相对定位的child box不将偏移计算在内。注意child box可能是匿名块盒； 另外，如果这个元素有任何浮动后代的底部外边界超出了在这个元素底部内容边界，这些超出的边界也计算在元素的高度之内注意：只有参与这个元素产生的BFC的浮动元素才会参与此元素的高度计算，在绝对定位的child box中的浮动元素不参与计算 BFC的应用这是一个测试的文档结构和样式123456&lt;div class="container"&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="other"&gt;&lt;/div&gt; 12345678910111213141516171819.container&#123; border:5px solid #000;&#125;.div1&#123; width: 200px; height: 100px; background-color: #43235e; margin: 10px 0;&#125;.div2&#123; width: 300px; height: 100px; background-color: #ee5511; margin: 10px 0;&#125;.other&#123; background-color: #666; height: 100px;&#125; 解决垂直margin重叠问题div1和div2的上下外边距重叠,间距两者最大值：30px div1 margin-bottom: 10pxdiv2 margin-top: 20px 第二条说：属于同一个BFC的相邻box的margin会发生重叠，那只要相邻的box不属于同一个BFC，垂直margin就不会重叠啦 div1 margin-bottom: 10pxdiv2 margin-top: 20px 自适应多栏布局下面div1左浮动，脱离了常规流，margin外边界与包含块左侧边框内边界接触，div2向上移动，与div1重叠。 div1 左浮动 div2 根据第四条：常规流中一个建立块格式化上下文的元素（触发BFC的元素）不会和任何浮动元素的外边界框重叠所以只要让div2形成BFC，就不会重叠了,这里还是用overflow的非visible属性生成BFC div1 左浮动 div2触发BFC 解决浮动元素父元素高度塌陷问题这里只有div1是浮动的，因为浮动元素脱离文档流，不参与父元素高度的计算 div1 左浮动div2 margin-top: 20px 根据第六条，如果一个生成BFC的元素有任何浮动后代的底部外边界超出了在这个元素底部内容边界，这些超出的边界也计算在元素的高度之内所以，如果让container触发BFC，浮动元素div1超出container的那部分也会计入container的高度,包括浮动元素div1的外边距 div1左浮动div2 margin-top: 20px BFC兼容性在IE6和IE7中不是所有元素都拥有布局，元素是否拥有布局由hasLayout属性决定，hasLayout与BFC相似，有触发hasLayoutyongyong（hasLayout == true）的条件，也有拥有布局后的一套规则。触发hasLayout的条件有： float: 非none display: inline-block position: absolute width: 非auto height: 非auto zoom: 非normal值 writing-mode: tb-rl hasLayout == true时的规则： 相对定位的元素没有布局 拥有布局的元素外边距不叠加 等等。。 在IE6和IE7中可以通过为元素添加zoom：1属性触发haslayout，修复因浮动引起的高度塌陷问题 参考 Box model Visual formatting model Visual formatting model details display]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端H5开发小经验]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Android手机软键盘挡住输入框？Android设置border-radius,背景颜色溢出？页面上数字变成可以点击的电话号码？ android手机软键盘挡住输入框在点击输入框时，软键盘升起会挡住输入框，IOS手机则会把输入框顶起来不会遮住。解决办法是:给输入框添加一个点击事件12345clickHandler(e)&#123; setTimeout(function(e)&#123; e.target.scrollIntoViewIfNeeded(); &#125;,400);&#125; android设置border-radius,背景颜色溢出background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框下面 border-box 背景延伸到边框外沿（但是在边框之下）。 padding-box 边框下面没有背景，即背景延伸到内边距外沿。 content-box 背景裁剪到内容区 (content-box) 外沿。123&#123; background-clip: padding-box;&#125; 页面上数字变成可以点击的电话号码123&lt;head&gt; &lt;meta name="format-detection" content="telephone=no"&gt;&lt;/head&gt; 点击输入框调出数字键盘12&lt;input type='number' pattern="[0-9]*"/&gt;&lt;input type='tel'&gt; ios click事件300ms延时最近有个项目，其中有个场景是这样的，一个批量选择图片的页面还带分页，在选择图片时checkbox从未选择状态变为已选择状态，在安卓上反映很快，在ios上表现很迟钝。原来这是因为click事件300ms延时导致的。 并不是只有ios才有click事件300ms延时，设计click事件300ms延时的原因是为了支持双击缩放，判断是否在300ms内有第二次点击。支持双机缩放这种功能的一都般会有单击延时的问题。chrome 和 firefox 的移动版本禁用缩放就可以解决300ms延时的问题 但是这在移动端safari上并不起作用。 可以通过监听 touchend事件处理， touchend事件没有延迟。另外还可以使用fastclick，可以看下 fastclick github ios autofocus不起作用移动端safari上不支持autofocus，可以查看MDN autofocus Browser_compatibility只能通过用户主动出发事件时手动聚焦。例如：1&lt;input type='text' id='focus'/&gt; 123document.addEventListener('touchend',function()&#123; document.getElementById('focus').focus();&#125;)]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用 Web API 接口]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8WebAPI%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[有时候是不是很容易头大，很多常见的api分不清，看下面这些，能弄明白它们的区别么？ document.location 与 window.location document.URL 与 document.documentURI nodeValue、innerText 、textContent、innerHTML、outerHTML、outerText clientHeight、scrollHeight、offsetHeight（Left/Top/Width） 要想知道它们有什么不同，还是得先捋捋它们都是谁的属性和方法，看看常用web api的继承关系，想想它们都有哪些属性和方法 EventTarget方法 EventTarget.addEventListener() EventTarget.removeEventListener() EventTarget.dispatchEvent() NodeNode是一个接口，许多DOM类型从这个接口继承,如Document，Element 属性 Node.baseURI Node.childNodes 所有子节点 Node.firstChild 第一个子节点 Node.lastChild 最后一个子节点 Node.previousSibling 前一个兄弟节点 Node.nextSibling 下一个兄弟节点 Node.parentNode 父节点(可能是元素节点也可能是文档节点) Node.parentElement 当前节点的父元素节点 Node.nodeValue 返回或设置当前节点的值 Node.nodeType 节点的类型 Node.nodeName 节点名称 Node.innerText 一个节点及其后代的“渲染”文本内容的属性 Node.textContent 一个节点及其后代的文本内容 Node.replaceChild(newChild, oldChild) 方法 parentNode.appendChild(child) 将一个节点添加到指定父节点的子节点列表末尾 parentNode.removeChild(child) Node.cloneNode 返回调用该方法的节点的一个副本 parentElement.contains( otherNode ) 传入的节点是否为该节点的后代节点 parentElement.hasChildNodes() 当前节点是否包含有子节点 parentElement.insertBefore(newElement, referenceElement) 节点类型常量 常量 值 描述 Node.ELEMENT_NODE 1 一个 元素 节点，例如 &lt;p&gt; 和 &lt;div&gt; Node.TEXT_NODE 3 Element 或者 Attr 中实际的 文字 Node.PROCESSING_INSTRUCTION_NODE 7 一个用于XML文档的 ProcessingInstruction ，例如 &lt;?xml-stylesheet … ?&gt; 声明 Node.COMMENT_NODE 8 一个 Comment 节点 Node.DOCUMENT_NODE 9 一个 Document 节点。 Node.DOCUMENT_TYPE_NODE 10 描述文档类型的 DocumentType 节点。例如 &lt;!DOCTYPE html&gt; 就是用于 HTML5 的。 Node.DOCUMENT_FRAGMENT_NODE 11 一个 DocumentFragment 节点 ParentNode属性 childElementCount children firstElementChild lastElementChild 方法 append() prepend() querySelectorAll() ChildNode方法 after() before() remove() Document属性 document.body document.characterSet document.doctype document.domain document.head document.body document.location document.documentURI document.URL 方法 document.createElement() document.createTextNode document.getElementById() document.getElementsByClassName() document.getElementsByName() document.getElementsByTagName() document.querySelector() document.querySelectorAll() document.write() document.writeln() Element属性 Element.attributes Element.classList Element.classList.add() Element.classList.remove() Element.classList.item() Element.classList.toggle() Element.classList.contains() Element.className Element.tagName Element.id Element.name Element.innerHTML Element.outerHTML Element.clientHeight Element.clientLeft Element.clientTop Element.clientWidth Element.scrollHeight Element.scrollLeft Element.scrollTop Element.scrollWidth 方法 Element.getElementsByClassName() Element.getElementsByTagName() Element.querySelector() Element.querySelectorAll() Element.getAttribute() Element.removeAttribute() HTMLElement属性 HTMLElement.offsetHeight HTMLElement.offsetLeft HTMLElement.offsetTop HTMLElement.offsetWidth HTMLElement.offsetParent 返回一个指向最近的包含该元素的定位元素 HTMLElement.style 123elt.style.cssText = &quot;color: blue&quot;; // 设置多个样式属性 elt.setAttribute(&quot;style&quot;, &quot;color: blue&quot;); // 设置多个样式属性 elt.style.color = &quot;blue&quot;; // 直接设置样式属性 HTMLElement.dataset 获取自定义的数据属性 HTMLElement.contentEditable 表明元素是否是可编辑的 HTMLElement.dir 获取或设置当前元素的元素内容的文本书写方向 方法 HTMLElement.click() 可以用来模拟鼠标左键单击一个元素 HTMLElement.blur() 用来移除当前元素所获得的键盘焦点 HTMLElement.focus() 可以设置指定元素获取焦点 Window属性 window.console window.document window.history 用来获取History 对象的引用 window.innerHeight 浏览器窗口的视口（viewport）高度（以像素为单位），包括水平滚动条 window.innerWidth 浏览器视口（viewport）宽度（单位：像素）包括垂直滚动条 window.location window.navigator 查询一些关于运行当前脚本的应用程序的相关信息 window.top 返回窗口体系中的最顶层窗口的引用 window.parent 返回当前窗口的父对象 方法 window.setInterval 重复调用一个函数或执行一个代码段，以固定的时间延迟在每次调用之间。返回一个 intervalID window.setTimeout 在定时到期后执行一段代码 window.resizeTo(aWidth, aHeight) 动态调整窗口的大小 区分相似接口属性document.location 与 window.location没发现有啥区别 Node.nodeValue、Node.innerText 、Node.textContent 、Element.innerHTML、Element.outerHTML1、Node.nodeValue返回或设置当前节点的值,不同类型的节点nodeValue值不同.nodeValue为null,对它赋值也没效果.|节点类型 | nodeValue的值|:—|:—|Node.COMMENT_NODE |注释的文本内容|Node.DOCUMENT_FRAGMENT_NODE | null|Node.DOCUMENT_TYPE_NODE | null|Node.ELEMENT_NODE | null|Node.TEXT_NODE | 文本节点的内容 2、Node.innerText表示一个节点及其后代的“渲染”文本内容。3、Node.textContent表示一个节点及其后代的文本内容 4、Element.innerHTML返回元素后代 HTML 文本 5、Element.outerHTML返回包含描述元素及其后代的序列化HTML片段 innerText意识到样式，并且不会返回隐藏元素的文本，而textContent会。innerText 受 CSS 样式的影响，它会触发重排（reflow），但textContent 不会textContent会获取所有元素的内容，包括 script 和 style 元素，而 innerText 不会innerHTML文本会被解析为HTML,但textContent不会，使用textContent可以防止XSS 攻击outerHTML不仅返回元素后代 HTML 文本，还包括元素本身例：12345&lt;div id="container"&gt; &lt;p class="p1"&gt;111&lt;/p&gt; &lt;p class="p2"&gt;222&lt;/p&gt; &lt;p class="p3"&gt;333&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021&gt;$(&apos;#container&apos;).innerText&quot;111222&quot;&gt;$(&apos;#container&apos;).textContent&quot; 111 222 &quot;&gt;$(&apos;#container&apos;).innerHTML&quot; &lt;p class=&quot;p1&quot;&gt;111&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;222&lt;/p&gt; &quot;&gt;$(&apos;#container&apos;).outerHTML&quot;&lt;div id=&quot;container&quot;&gt; &lt;p class=&quot;p1&quot;&gt;111&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;222&lt;/p&gt; &lt;/div&gt;&quot;&gt;$(&apos;#container&apos;).nodeValuenull Element.clientHeight、Element.scrollHeight、HTMLElement.offsetHeight（Left/Top/Width）1、Element.clientHeight只读属性，返回元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。2、Element.scrollHeight只读属性，计量元素内容高度，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与clientHeight值相同3、HTMLElement.offsetHeight只读属性,返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。通常，元素的offsetHeight是一种衡量标准，包括元素的边框、垂直内边距和元素的水平滚动条（如果存在且渲染的话）和元素的CSS高度。 例如：12345678910111213141516 &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;111&lt;/p&gt;&lt;/div&gt;#container&#123; width: 200px; height: 200px; border: 5px solid #ff6633; overflow: scroll; padding: 3px;&#125;.content&#123; height: 300px; width: 100px; border: 10px solid #000;&#125; 12345678910111213&gt;$(&apos;#container&apos;).clientHeight206 &gt;$(&apos;#container&apos;).scrollHeight326 &gt;$(&apos;#container&apos;).offsetHeight216&gt;$(&apos;.content&apos;).clientHeight300&gt;$(&apos;.content&apos;).scrollHeight300&gt;$(&apos;.content&apos;).offsetHeight320 参考 EventTarget Window Node ParentNode ChildNode Element Document HTMLElement GlobalEventHandlers]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序初体验]]></title>
    <url>%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[小程序刚出来的时候就刷爆了朋友圈，各种铺天盖地的文章说是小程序的到来要改变前端的开发模式，不再需要客户端开发云云。。当时我也是热血沸腾，以为属于前端的时代来了，加入了“微信应用号开发群-4”，关注了微信公众号“很小的程序”，还加入了github上的组织“微信小程序开发者”。每天看着群里各种开发中遇到的问题抛出来，大家聊得很high，然而我也就运行了一下官方demo，浏览了一遍官网文档。大概那时候是没有太多时间去学习了。。。。现在已经有很多小程序上线了，我也下载了很多，像 滴滴出行 大众点评+ 摩拜单车 印象笔记微清单 美柚App 京东购物 然而体验了一番后，除了 印象笔记微清单 和 美柚App 其他的都删了。 出行类APP 滴滴出行和摩拜单车 因为体验没有下载的客户端应用好购物类APP 大众点评+和京东购物 因为功能太简单了 不满足我的需求 留下印象笔记微清单和美柚App只是因为功能比较简单又好用，一个记录我要做的事情，一个记录姨妈周期。 最近看到群里有人在问，小程序是不是要死了？哈哈，确实，还真没预期的那样好，我身边都没有人用呀。。。 效果正好最近事情不多，恩，可以写个小程序体验一下了。找了个口碑外卖的模子，按照口碑外卖的视觉和交互，写了个小程序，半拉子，没有完全写好，以后有时间再补咯。 现在是长这样子，代码在 小程序-口碑外卖 开发中遇到的问题虽然只是简单的几个页面，遇到的问题还是不少。 navigation无法跳转 页面跳转有两种方法，一个是用navigation组件，还有一个是绑定事件，在事件处理器中调用小程序提供的navigate api 在使用navigation组件跳转页面时可能会出现无法跳转的问题，有几种可能原因： 所有要跳转的页面都要配置在app.json的pages属性中 对于open-type=”navigate”和open-type=”redirect” 跳转的应用内得是 非 tabBar的页面的路径。 对于open-type=”switchTab”，跳转的页面必须在app.json的tabBar属性中配置 无法使用js操作DOM如果想获得当前DOM的信息，可以在组件上自定义data-*属性，并通过绑定事件函数获取事件对象，从e.currentTarget.dataset中获取数据。如：12345&lt;view data-shopId="123" bindtap="toggleClick"&gt;&lt;/view&gt;function toggleClick(e)&#123; let dataset = e.currentTarget.dataset; console.log(dataset.shopid);&#125; 注意： data-属性中的都会被转成小写 CSS尺寸单位最好使用rpx刚开始使用的px，同样的尺寸，在iphone6上显示正常，在iphone5上就被挤掉了，在iphone6 plus上尺寸又变得很小不美观。rpx对设备尺寸做了自适应。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 循环渲染时要加上wx:key=”id”不然会warning，Now you can provide attr “wx:key” for a “wx:for” to improve performance.加上可提升重新渲染时的效率 swiper组件可支持垂直轮播，官方文档中没有写,不知道是为啥。1&lt;swiper vertical="true"&gt;&lt;/swiper&gt; 简单的组件化在index页面的js,wxml,wxss文件中分别引入组件Shop对应文件 12345678//index.jsimport Shop from '../../component/shop/shop.js';//index.wxml &lt;import src="../../component/shop/shop.wxml" /&gt;//index.wxss@import "../../component/shop/shop.wxss"; 参考 小程序 官方文档]]></content>
      <categories>
        <category>小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript浮点运算在某些情况下产生误差]]></title>
    <url>%2Fjavacript%E4%B8%AD%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E4%BA%A7%E7%94%9F%E8%AF%AF%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[商家创建一个发礼品券的活动，券金额0.1, 库存9999，那么活动成本是：0.1 × 9999 = 999.9000000000001额。。。 不应该是99.99么？？原来计算机进行四则运算时，在某些情况下会有误差，这是在safari上的测试结果。0.1 + 0.2 = 0.300000000000000041.0 - 0.8 = 0.199999999999999961.6 × 9999 = 15998.400000000001999.9 ÷ 9999 = 0.09999999999999999 误差原因要弄明白出现这种问题的原因，得知道计算机是怎么处理小数的。计算机处理的是二进制数据，只有0和1。将十进制整数转换成二进制很简单，商除以2取余，小数点左侧从右向左排列就是整数部分二进制了。将小数部分转换成二进制，小数部分乘以2取整，小数点右侧从左向右排列就是小数部分的二进制，就可能出现无限循环。例如:十进制 6.1二进制 110.0001 1001 1001 1001 …整数部分 6 ，余数在小数点左侧的顺序 110.6 ÷ 2 = 3 … 03 ÷ 2 = 1 … 11 ÷ 2 = 0 … 1小数部分 0.1 , 取结果的整数部分，结果的小数部分继续乘以2，知道结果没有小数部分为止在小数点右侧的顺序 .0001 1001 1001 …0.1 × 2 = 0.2 0.2 + 00.2 × 2 = 0.4 0.4 + 00.4 × 2 = 0.8 0.8 + 00.8 × 2 = 1.6 0.6 + 10.6 × 2 = 1.2 0.2 + 10.2 × 2 = 0.4 0.4 + 00.4 × 2 = 0.8 0.8 + 00.8 × 2 = 1.6 0.6 + 10.6 × 2 = 1.2 0.2 + 10.2 × 2 = 0.4 0.4 + 00.4 × 2 = 0.8 0.8 + 00.8 × 2 = 1.6 0.6 + 1…说明，有些十进制小数是不能用二进制有限位数表示的。 十进制 二进制 0.1 0.0001 1001 1001 1001 … 0.2 0.0011 0011 0011 0011 … 0.3 0.0100 1100 1100 1100 … 0.4 0.0110 0110 0110 0110 … 0.5 0.1 0.6 0.1001 1001 1001 1001 … 计算机无法表示无限小数，会进行取舍，从而造成误差。 解决办法对于加减法和乘法，可以先将参加运算的小数扩大n倍，变成整数，整数运算后再缩小n倍。对于除法，可以两个参数同时扩大n倍，再运算。例如加法运算：1234567891011function cadd(arg1,arg2)&#123; var max_decimal_length,l1,l2,expand_multiple; l1 = arg1.toString().split('.')[1].length; l2 = arg2.toString().split('.')[1].length; max_decimal_length = l1 &gt; l2 ? l1 : l2; //最长的小数位数 expand_multiple = Math.pow(10, Math.max(l1, l2)); //扩大倍数 return (arg1 * expand_multiple + arg2 * expand_multiple) / expand_multiple;&#125;Number.prototype.add = function(arg)&#123; return cadd(arg,this);&#125;; 参考 妥协与取舍，解构计算机中的二进制浮点数运算 浮点数的二进制表示]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【jQuery源码】从事件绑定看缓存设计]]></title>
    <url>%2FjQuery%E6%BA%90%E7%A0%81-%E4%BB%8E%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9C%8B%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[当事件绑定顺序如下：123456789101112&lt;div id="J_content"&gt; &lt;button id="J_jump"&gt;跳转&lt;/button&gt; &lt;button id="J_jump1"&gt;跳转1&lt;/button&gt;&lt;/div&gt;&lt;script src="./jquery-3.1.1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $('#J_content').on('click',clickHandler); $('#J_content').on('click',clickHandler); $('#J_content').on('click','#J_jump',clickHandler); $('#J_content').on('click','#J_jump1',clickHandler1); $('#J_content').on('mousedown','#J_jump1',clickHandler1);&lt;/script&gt; dataPriv.get(elem)得到的结果如下，其中elem是id为J_content的DOM节点,dataPriv.get(elem)中存放的是elem元素的相关数据（这里是绑定的事件信息)。 而dataPriv由 var dataPriv = new Data();而来，jQuery设计了缓存系统，在给元素绑定事件时，事件信息不是直接依附在dom元素上，而是将事件信息放在缓存中，与dom元素关联。这样可以有效的避免内存泄漏。 jQuery缓存设计原理var dataPriv = new Data();elemData = dataPriv.get( elem );使用get方法去cache中取值。 jQuery缓存的设计思路是这样的： 对于DOM元素，给其扩展一个属性，属性名是jQuery.expando + Data.uid++的值 将数据存放在该属性中，也就是该属性的属性值就是要存储的数据 这样在读取、设置、和移除都是操作这个属性 直观一点就是下面这样，其实就是原本要直接附加到DOM元素上的对象，附加到DOM元素一个新的属性上。给DOM节点elem绑定事件，事件对象都存放在elem的jQuery311093659233154491051属性中 Data类这个缓存机制的实现由Data类完成,Data类的提供的实例方法都是对扩展属性(jQuery311093659233154491051)及其对象属性的操作。1234567891011121314151617181920212223242526272829303132333435363738function Data() &#123; //每个页面都会生成一个jQuery的唯一标识 // jQuery.expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),如jQuery31109365923315449105 this.expando = jQuery.expando + Data.uid++; //结果是： jQuery311093659233154491051&#125;Data.uid = 1;Data.prototype = &#123; cache: function( owner ) &#123; //当owner是id为J_content的DOM节点 var value = owner[ this.expando ]; if ( !value ) &#123; value = &#123;&#125;; // cache中如果没有，就创建&#123;&#125;,在内存中开辟区域存储 if ( acceptData( owner ) ) &#123; if ( owner.nodeType ) &#123; //并让DOM节点的jQuery311093659233154491051属性指向这个内存区域 owner[ this.expando ] = value; &#125; else &#123; Object.defineProperty( owner, this.expando, &#123; value: value, configurable: true &#125; ); &#125; &#125; &#125; return value; &#125;, get: function( owner, key ) &#123; return key === undefined ? this.cache( owner ) : // Always use camelCase key (gh-2257) owner[ this.expando ] &amp;&amp; owner[ this.expando ][ jQuery.camelCase( key ) ]; &#125;, set: function( owner, data, value ) &#123;... &#125;, access: function( owner, key, value ) &#123;...&#125;, remove: function( owner, key ) &#123;...&#125;, hasData: function( owner ) &#123;...&#125;&#125;;var dataPriv = new Data(); //jQuery内部使用,如事件var dataUser = new Data(); //给开发者使用，如$.attr(),$.date() 参考 jQuery官网 jQuery GitHub 慕课网 jQuery源码解析（架构与依赖模块）]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>jQuery3.1.1源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【jQuery源码】事件绑定与解绑]]></title>
    <url>%2FjQuery%E6%BA%90%E7%A0%81-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E7%BB%91%2F</url>
    <content type="text"><![CDATA[jQuery事件是DOM事件的封装，提供了一些事件绑定和触发的方法,并且支持自定义事件。 绑定事件 bind delegate on one blur focus focusin focusout resize scroll …等事件名方法 解绑事件 unbind undelegate off 触发事件 trigger 对外提供的方法从源码看1、绑定事件的bind、delegate最终都是调用jQuery.prototype.on方法，jQuery.prototype.on调用的是一个全局的on方法 on( elem, types, selector, data, fn, one ) ，与on方法的区别： bind方法的selector是null,不支持传入selector delegate方法只是参数的传入顺序与on方法不同,jQuery 3.0中已弃用此方法，用 on()代替。 2、 移除事件的unbind、undelegate最终都是调用jQuery.prototype.off方法function( types, selector, fn ) ,与off方法的区别： unbind方法的selector是null,不支持传入selector undelegate方法只是参数的传入顺序与off方法不同 3、 one方法绑定的事件处理器只执行一次，它与on方法相同，调用的全局的on方法12345678910111213141516171819202122232425262728jQuery.fn.extend( &#123; bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;, unbind: function( types, fn ) &#123; return this.off( types, null, fn ); &#125;, delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125;, undelegate: function( selector, types, fn ) &#123; // ( namespace ) or ( selector, types [, fn] ) return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn ); &#125;&#125; );jQuery.fn.extend( &#123; on: function( types, selector, data, fn ) &#123; return on( this, types, selector, data, fn ); &#125;, one: function( types, selector, data, fn ) &#123; return on( this, types, selector, data, fn, 1 ); &#125;, off: function( types, selector, fn ) &#123; .... &#125;&#125; ); jQuery还提供了一种绑定事件的方法,将事件类型名作为jQuery.prototype的方法属性名，所以我们还可以这样绑定事件：$(‘#id’).click(eventHandler)。12345678910111213141516jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu" ).split( " " ), function( i, name ) &#123; // Handle event binding jQuery.fn[ name ] = function( data, fn ) &#123; return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name ); &#125;;&#125; );jQuery.fn.extend( &#123; hover: function( fnOver, fnOut ) &#123; return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver ); &#125;&#125; ); on函数jQuery.prototype上绑定事件的方法 bind、delegate、on、one最终都是调用全局的on( elem, types, selector, data, fn, one )方法，有这些参数： elem 数组类型 要绑定事件的dom元素 types 事件对象(a map of types/handlers) 或者事件类型(click、change) selector 选择器 data 附加参数，在使用trigger方法触发事件时传入，用户操作触发时，data是undefined fn 事件处理函数，事件触发后要做的事情 one 传入参数为1，事件只执行一次，然后移除事件on方法的绝大部分代码都是在处理参数不同（数量和类型）的情况下，统一调用jQuery.event.add( this, types, fn, data, selector )方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function on( elem, types, selector, data, fn, one ) &#123; var origFn, type; // Types can be a map of types/handlers // 例如$('#id').on(&#123;click:clickHandler,change:changeHandler&#125;,'#id0',&#123;name:'on'&#125;) if ( typeof types === "object" ) &#123; // 【1】( types-Object, selector, data ) types是object时只有三个参数的情况 // 当types是一个对象时，需要对每一个type依次绑定对应的事件处理器 // 并在一次调用on方法前做个参数处理 if ( typeof selector !== "string" ) &#123; //【2】( types-Object, data ) // 如果第三个参数不是string类型，那参数中就没有selector // 例如$('#id').on(&#123;click:clickHandler,change:changeHandler&#125;,&#123;name:'on'&#125;) data = data || selector; // data = null || &#123;name:'on'&#125; selector = undefined; &#125; for ( type in types ) &#123; on( elem, type, selector, data, types[ type ], one ); &#125; return elem; &#125; //如果第4位参数data 和第5位参数fn没有，即$('#id').on(param1,param2)这样只有两位参数 //elem之后的参数依次是事件类型和事件处理函数 if ( data == null &amp;&amp; fn == null ) &#123; // 【3】( types, fn ) 只有两个参数，事件类型和事件处理器 fn = selector; data = selector = undefined; &#125; else if ( fn == null ) &#123; if ( typeof selector === "string" ) &#123; // 【4】( types, selector, fn ) 三个参数，事件类型，过滤elem后代元素的选择器，事件处理器 fn = data; data = undefined; &#125; else &#123; //【5】( types, data, fn ) fn = data; data = selector; selector = undefined; &#125; &#125; //【6】fn也可以是一个false值，在on方法中fn为false时，转为一个直接返回false的函数，作为后续调用的jQuery.event.add方法的参数 // false值就是做一个直接返回false的函数的简写 if ( fn === false ) &#123; fn = return false; &#125; else if ( !fn ) &#123; //如果没有事件处理器就啥也不干，返回这个dom元素 return elem; &#125; //【7】事件只会触发一次就移除时，对事件处理函数进行封装 //第一次触发执行时，先移除事件处理器，再执行事件 if ( one === 1 ) &#123; origFn = fn; fn = function( event ) &#123; // Can use an empty set, since event contains the info jQuery().off( event ); return origFn.apply( this, arguments ); &#125;; // Use same guid so caller can remove using origFn fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ ); &#125; return elem.each( function() &#123; jQuery.event.add( this, types, fn, data, selector ); &#125; );&#125; jQuery.event.add方法jQuery.event.add将每个事件处理器封装成事件处理对象，包括唯一标识、事件处理函数、选择器等属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091add: function( elem, types, handler, data, selector ) &#123; var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get( elem ); // 对elem第一次绑定事件前，elemData为空对象&#123;&#125; if ( !elemData ) &#123; return; &#125; // 传入的形式是&#123;handler：handler，selector：selector&#125; if ( handler.handler ) &#123; handleObjIn = handler; handler = handleObjIn.handler; selector = handleObjIn.selector; &#125; // 判断选择器是否存在 if ( selector ) &#123; jQuery.find.matchesSelector( documentElement, selector ); &#125; // 给事件处理器添加唯一标识 if ( !handler.guid ) &#123; handler.guid = jQuery.guid++; &#125; // 第一次给该元素绑定时初始化elemData的events属性和handle属性 if ( !( events = elemData.events ) ) &#123; events = elemData.events = &#123;&#125;; &#125; if ( !( eventHandle = elemData.handle ) ) &#123; eventHandle = elemData.handle = function( e ) &#123; // Discard the second event of a jQuery.event.trigger() and // when an event is called after a page has unloaded return typeof jQuery !== "undefined" &amp;&amp; jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply( elem, arguments ) : undefined; &#125;; &#125; types = ( types || "" ).match( rnothtmlwhite ) || [ "" ]; t = types.length; while ( t-- ) &#123; tmp = rtypenamespace.exec( types[ t ] ) || []; type = origType = tmp[ 1 ]; namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort(); if ( !type ) &#123; continue; &#125; // If event changes its type, use the special event handlers for the changed type special = jQuery.event.special[ type ] || &#123;&#125;; // If selector defined, determine special event api type, otherwise given type type = ( selector ? special.delegateType : special.bindType ) || type; // Update special based on newly reset type special = jQuery.event.special[ type ] || &#123;&#125;; // handleObj is passed to all event handlers handleObj = jQuery.extend( &#123; type: type, origType: origType, data: data, handler: handler, guid: handler.guid, selector: selector, needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ), namespace: namespaces.join( "." ) &#125;, handleObjIn ); // 在events对象中，存储该元素绑定事件对应的事件处理器数组 // 对该元素的某一类型事件第一次绑定事件处理器时，对handlers初始化为空数组[] if ( !( handlers = events[ type ] ) ) &#123; handlers = events[ type ] = []; handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false // 只有在此种条件下才会直接用addEventListener绑定事件 if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) &#123; if ( elem.addEventListener ) &#123; elem.addEventListener( type, eventHandle ); &#125; &#125; &#125; if ( special.add ) &#123; special.add.call( elem, handleObj ); if ( !handleObj.handler.guid ) &#123; handleObj.handler.guid = handler.guid; &#125; &#125; // 将处理器对象存放在dataPriv.get( elem )[type].handlers中 // 如果是事件代理，处理器对象放在列表前面，用splice实现，将handleObj插入最后一个事件代理处理器之后 if ( selector ) &#123; handlers.splice( handlers.delegateCount++, 0, handleObj ); &#125; else &#123; //如果不是事件代理，直接放在列表最后，用push即可 handlers.push( handleObj ); &#125; jQuery.event.global[ type ] = true; &#125; &#125; 当事件绑定顺序如下：12345$('#J_content').on('click',clickHandler);$('#J_content').on('click',clickHandler);$('#J_content').on('click','#J_jump',clickHandler);$('#J_content').on('click','#J_jump1',clickHandler1);$('#J_content').on('mousedown','#J_jump1',clickHandler1); events的内容为： 其中guid为事件处理器的唯一标识，事件处理器clickHandler的guid为1，clickHandler1的guid为2。 events中存放每个事件对应的多个事件处理器对象 当类型相同、处理器相同是，也会存入一个事件处理器对象 对于同一类型的事件处理器，事件代理处理器总会放在前面事件绑定用法12345678910111213function clickHandler()&#123; console.log("事件处理");&#125;$('#J_confirm').click(clickHandler);$('#J_confirm').on('click',clickHandler);$('#J_confirm').on(&#123; click: clickHandler, mousedown: clickHandler&#125;);$('#J_confirm').bind('click',clickHandler)$('#J_content').on('click','#J_jump',clickHandler);$('#J_content').one('click','#J_jump',clickHandler);$('#J_confirm').one('click',clickHandler); 用trigger触发事件：1234567function clickHandler(e,name)&#123; console.log(name + &quot; 事件处理&quot;);&#125;$(&quot;#J_confirm&quot;).click(clickHandler);$(&quot;#J_confirm&quot;).trigger(&quot;click&quot;, &quot;use trigger&quot;);// 可简写如下$(&quot;#J_confirm&quot;).click(clickHandler).trigger(&quot;click&quot;, &quot;use trigger&quot;); off方法123456789101112131415161718192021222324252627282930313233off: function( types, selector, fn ) &#123; var handleObj, type; if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) &#123; // ( event ) dispatched jQuery.Event handleObj = types.handleObj; jQuery( types.delegateTarget ).off( handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler ); return this; &#125; if ( typeof types === "object" ) &#123; // ( types-object [, selector] ) for ( type in types ) &#123; this.off( type, selector, types[ type ] ); &#125; return this; &#125; if ( selector === false || typeof selector === "function" ) &#123; // ( types [, fn] ) fn = selector; selector = undefined; &#125; if ( fn === false ) &#123; fn = returnFalse; &#125; return this.each( function() &#123; jQuery.event.remove( this, types, fn, selector ); &#125; ); &#125; jQuery.event.remove方法remove方法最终调用javascript提供的removeEventListener123if ( elem.removeEventListener ) &#123; elem.removeEventListener( type, handle ); &#125; 事件解绑用法参考 jQuery官网 jQuery GitHub jQuery API 3.1.0 速查表 –作者：Shifone 慕课网 jQuery源码解析（DOM与核心模块）]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>jQuery3.1.1源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS小经验]]></title>
    <url>%2FCSS%E5%B0%8F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[隐藏滚动条见::-webkit-scrollbar12345678.visible-scrollbar, .invisible-scrollbar &#123; display: block; width: 10em; overflow: auto;&#125;.invisible-scrollbar::-webkit-scrollbar &#123; display: none;&#125; display:inline-block 元素之间有空白间隙1234567ul&#123; width:100%;&#125;li&#123; width:50%; display:inline-block;&#125; 如果html结构写成这样，两个li中间会有间隙假设为n px ,那这一行就放不下两个li1234&lt;ul&gt; &lt;li&gt;第一个&lt;/li&gt; &lt;li&gt;第二个&lt;/li&gt;&lt;/ul&gt; 最好的解决办法是将html结构写成这样12345&lt;ul&gt; &lt;li&gt; 第一个&lt;/li&gt;&lt;li&gt; 第二个&lt;/li&gt;&lt;/ul&gt; 定宽不换行white-space: nowrap; 单行文本溢出显示省略号有两个条件 设置文本显示在一行 white-space:nowrap 溢出时隐藏内容 overflow:hidden再设置：text-overflow:ellipsis ellipsis翻译：（语法结构上的）省略 多行文本移除显示省略号1234567// 仅适用于webkit内核浏览器p&#123; display: -webkit-box; //设置display，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient: vertical; //规定框的子元素应该被水平或垂直排列 -webkit-line-clamp: 4; //限制在一个块元素显示的文本的行数 overflow: hidden;&#125; z-index无效需要设置position属性为非static值 弹窗滚动到底时，后面的页面也跟着滚动在点开弹窗时给html和body添加class ： 1234.forbidden-root-scroll&#123; overflow:hidden; height:100%;&#125; 关闭弹窗时remove class 这样设置会让页面重置到没有滚动的状态。这样会造成一个问题，比如查看第二页时点击弹窗，页面会重置到第一页，关闭弹窗时就不是原来的位置了。所以在添加上面的属性之前要先记下body的scrollTop，remove class之后设置body的scrollTop为前面记下的值。 12345678910111213141516171819this.html = document.getElementsByTagName(&apos;html&apos;)[0];this.body = document.getElementsByTagName(&apos;body&apos;)[0];this.scrollTop = 0forbiddenRootScroll(flag)&#123; if(flag)&#123; this.scrollTop = this.body.scrollTop this.html.setAttribute(&apos;class&apos;,&apos;forbidden-root-scroll&apos;) this.body.setAttribute(&apos;class&apos;,&apos;forbidden-root-scroll&apos;) &#125;else&#123; this.html.removeAttribute(&apos;class&apos;,&apos;forbidden-root-scroll&apos;) this.body.removeAttribute(&apos;class&apos;,&apos;forbidden-root-scroll&apos;) this.body.scrollTop = this.scrollTop &#125;&#125;//打开弹窗调用this.forbiddenRootScroll(true)//关闭弹窗调用this.forbiddenRootScroll(false) input placeholder与value重叠妖孽的问题啊 等我复现了再研究是个什么鬼]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下雨天]]></title>
    <url>%2F%E4%B8%8B%E9%9B%A8%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[周末依然宅公司午餐是水果Family留个照欧耶~~]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【jQuery源码】第一篇]]></title>
    <url>%2FjQuery%E6%BA%90%E7%A0%81-%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[在使用jQuery的过程中遇到很多的疑惑。jQuery为什么可以用美元符$表示？事件绑定的几个方法bind、delegate、on之间有什么区别？jQuery怎么判断checkbox是否被选中，有哪几种方法？这样的问题有很多，还记不住，日常使用到的jQuery API，既然用到了，就学习一下源码吧~理解了实现，就不怕忘记了。目前学习的版本是3.1.1，代码已经1万+行了。最新源码可从jquery GitHub获取。 总体结构JQuery的源码是一个立即执行的函数,带两个参数,对象global和函数factory global &gt; typeof window !== “undefined” ? window : this factory &gt; function( window, noGlobal ) { … } factory函数是构建jQuery的工厂，提供jQuery各种方法。当作为模块被引入时，输出jQuery，在浏览器中直接使用时，将jQuery赋给window.$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344( function( global, factory ) &#123; "use strict"; if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) &#123; module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document"); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;&#125; )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) &#123; //jQuery 是一个函数 var jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context ); &#125;; // 核心方法 // 回调系统 // 异步队列 // 数据缓存 // 队列操作 // 选择器引 // 属性操作 // 节点遍历 // 文档处理 // 样式操作 // 属性操作 // 事件体系 // AJAX交互 // 动画引擎 if ( typeof define === "function" &amp;&amp; define.amd ) &#123; define( "jquery", [], function() &#123; return jQuery; &#125; ); &#125; //在没有作为模块引入时，将jQuery赋给window.$和window.jQuery if ( !noGlobal ) &#123; window.jQuery = window.$ = jQuery; &#125; return jQuery;&#125; ); 当在其他模块中通过require(jQuery)的形式（CommonJS AMD等规范引入模块的方式）引入，并且在浏览器环境下，那这个代码的逻辑是这样的，将jQuery输出 12345678module.exports = function( window, true ) &#123; ... if ( typeof define === "function" &amp;&amp; define.amd ) &#123; define( "jquery", [], function() &#123; return jQuery; &#125; ); &#125;&#125; 当在其他模块中通过require(jQuery)的形式引入，但不是在浏览器环境下，比如在nodejs环境中，global.document是不存在的，那逻辑就是这样。输出模块时抛出错误，提示当前环境因为没有window.document而不支持jQuery 123456module.exports = function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;; 如果不是用require(jQuery)的形式引入，比如直接使用window.$，逻辑就是这样的，将构建好的jQuery赋给window.$和window.jQuery，这样就可以直接使用$了。 12345function( window, false ) &#123; ... window.jQuery = window.$ = jQuery; return jQuery;&#125; 在浏览器中 window == this，window.document存在，在nodejs环境下 global == this，不存在global.document。所以在nodejs环境中是不支持jQuery的。 JQuery扩展方法extend源码中extend方法的使用给jQuery自身和jQuery原型都定义了一个extend方法，在jQuery源码内部大部分jQuery和jQuery原型的属性都是用extend方法扩展的，jQuery的extend方法也常用来扩展对象，或者用于jQuery插件的开发。在jQuery中定义和使用extend如下1234567891011121314//设置prototype属性jQuery.fn = jQuery.prototype = &#123; ... &#125;;//给jQuery自身和jQuery原型都定义一个extend方法，//用于扩展jQuery和jQuery.prototype的属性jQuery.extend = jQuery.fn.extend = function() &#123; ... &#125;;jQuery.fn.extend( &#123; on: function( types, selector, data, fn ) &#123; ... &#125;, one: function( types, selector, data, fn ) &#123; ... &#125;, off: function( types, selector, fn ) &#123; ... &#125; &#125;);jQuery.extend( &#123; attr: function( elem, name, value ) &#123; ... &#125;, removeAttr: function( elem, value ) &#123; ... &#125;&#125; ); extend方法实现解析extend方法将参数都合并到target中,用法是这种形式： $.extend(target,src1,src2,…) 如果第一个参数是布尔值，target就是第二个参数 如果第一个参数不是布尔值，target就是第一个参数 如果只有一个参数，target就是jQuery本身 如果target不是object类型或者函数类型，target就是{}扩展后返回的是target,所以如果不希望影响原有参数，可以设定一个空对象{}作为target,如$.extend({},src1,src2,…)或$.extend(true,{},src1,src2,…)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length,deep =false; //如果第一个参数是一个布尔值，根据这个布尔值决定是否深拷贝 if ( typeof target === "boolean" ) &#123; deep = target; // 如果第一个参数是一个布尔值，第二个参数作为target target = arguments[ i ] || &#123;&#125;; i++; &#125; // 如果target不是对象也不是函数，则将&#123;&#125;作为target，并且这个非对象的target不会被合并 if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // target就是jQuery if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // 只处理非null 非undefined值 if ( ( options = arguments[ i ] ) != null ) &#123; // 合并每个参数对象的每一个属性 for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // 已经合并的到target的就不再合并，如果要合并的参数中有相同的属性，但是属性值不同，会被覆盖 if ( target === copy ) &#123; continue; &#125; // 如果属性值是对象或者数组，并且deep为true,递归扩展，clone是子对象扩展的target if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = jQuery.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; //子对象合并后的结果 target[ name ] = jQuery.extend( deep, clone, copy ); // 如果属性值是undefined，不会合并到target中 &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // 返回最终合并的结果 return target;&#125;; extend的用法如果有相同属性，且属性值都是对象var src1 = {name:”chang”,info:{age:24,sex:1,time:”2016”}};var src2 = {name:”chen”,info:{age:26,sex:2,birth:”1945”}}; 子对象递归合并$.extend(true,{},src1,src2);123456789Object info: Object age: 26 birth: &quot;1945&quot; sex: 2 time: &quot;2016&quot; __proto__: Object name: &quot;chen&quot; __proto__: Object 子对象后者属性值覆盖前者$.extend({},src1,src2); $.extend(false,{},src1,src2);12345678Object info: Object age: 26 birth: &quot;1945&quot; sex: 2 __proto__: Object name: &quot;chen&quot; __proto__: Object 有相同属性，但是只有一个属性是对象的情况var src1 = {namee:”chang”,info:{age:24,sex:1,time:”2016”}};var src2 = {namee:”chen”,info:1234}; true + 子对象info合并时不进行深度合并最后的src2合并时由于不是对象，所以不会进行深度合并，直接覆盖target中已有的info$.extend(true,{},src1,src2);1Object &#123;namee: &quot;chen&quot;, info: 1234&#125; true + 子对象info合并时,target不是对象则不合并子对象info合并时，是这样的，$.extend(true,1234,{age:24,sex:1,time:”2016”})第一个合并参数不是对象，所有target是{}$.extend(true,{},src2,src1)12345678Object info: Object age: 24 sex: 1 time: &quot;2016&quot; __proto__: Object namee: &quot;chang&quot; __proto__: Object 合并到自身$.extend(src1);$.info;1Object &#123;age: 24, sex: 1, time: &quot;2016&quot;&#125; 参考 jquery官网 jquery GitHub]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>jQuery3.1.1源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery在动态生成的节点上绑定事件无效]]></title>
    <url>%2FJquery%E5%9C%A8%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84DOM%E8%8A%82%E7%82%B9%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[在有些情况下，需要在DOM节点存在之前就给这个节点绑定事件，在使用Jquery给尚不存在的dom节点绑定事件时发现并不起作用，事件并没有绑定在dom节点上，但也不报错。而使用原生的JavaScript绑定事件，如果绑定事件的DOM节点不存在，是会报错的。 原生JS绑定事件1234567891011121314151617181920212223242526272829303132333435363738&lt;html !DOCTYPE&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;原生js绑定事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="J_confirm"&gt;确定&lt;/button&gt; &lt;div id="J_content"&gt; &lt;!-- 动态生成dom节点 --&gt; &lt;!-- &lt;button id="J_jump"&gt;跳转&lt;/button&gt; --&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 已存在节点 document.getElementById('J_confirm').onclick=function()&#123; console.log("J_confirm is clicked."); &#125;; // 在尚未生成的节点上绑定事件 document.getElementById('J_jump').onclick=function()&#123; console.log("J_jump is clicked without event delegate using onclick."); &#125;; // 在尚未生成的节点上绑定事件 document.getElementById('J_jump').addEventListener('click',function()&#123; console.log("J_jump is clicked without event delegate using addEventListener."); &#125;); // 在事件绑定之后才生成节点 document.getElementById('J_content').appendChild(); function genNode()&#123; var node = document.createElement('button'); node.setAttribute('id','J_jump'); node.append("跳转"); return node; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 先给id为J_jump的dom节点绑定事件，然后再生成此节点，刷新页面就会报错，动态产生的跳转按钮也不会出现在页面上。 123Uncaught TypeError: Cannot read property &apos;addEventListener&apos; of nullUncaught TypeError: Cannot set property &apos;onclick&apos; of null JQuery绑定事件而使用Jquery在未生成的节点上绑定事件，跳转按钮是会正常展示的，但是点击没有反应。1234567891011121314151617181920&lt;html !DOCTYPE&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;动态生成的元素绑定事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="J_confirm"&gt;确定&lt;/button&gt; &lt;div id="J_content"&gt;&lt;/div&gt; &lt;script src="https://code.jquery.com/jquery-3.0.0.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $('#J_confirm').on('click',function()&#123; console.log("J_confirm is clicked."); &#125;); $('#J_jump').on('click',function()&#123; console.log("J_jump is clicked."); &#125;); $('#J_content').html('&lt;button id="J_jump"&gt;跳转&lt;/button&gt;'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 原生JS事件委托可以通过事件代理解决这个问题，在使用原生的javascript绑定事件时，可以将事件绑定在确定会存在的祖先节点上，委托祖先节点处理事件.12345678910111213141516171819202122232425262728293031323334353637383940&lt;html !DOCTYPE&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;原生js绑定事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="J_confirm"&gt;确定&lt;/button&gt; &lt;div id="J_content"&gt; &lt;!-- &lt;button id="J_jump"&gt;跳转&lt;/button&gt; --&gt; &lt;!-- 动态生成dom节点 --&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 已存在节点 document.getElementById('J_confirm').onclick=function()&#123; console.log("J_confirm is clicked."); &#125;; // 事件委托 document.getElementById('J_content').onclick=function(e)&#123; var target = e.target; console.log(target.innerText + " is clicked with event delegate using onclick."); &#125;; // 事件委托 document.getElementById('J_content').addEventListener('click',function(e)&#123; var target = e.target; console.log(target.innerText + " is clicked with event delegate using addEventListener."); &#125;); // 在事件绑定之后才生成节点 document.getElementById('J_content').appendChild(genNode("跳转1")); document.getElementById('J_content').appendChild(genNode("跳转2")); function genNode(text)&#123; var node = document.createElement('button'); node.setAttribute('id','J_jump'); node.append(text); return node; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出：1234跳转1 is clicked with event delegate using onclick.跳转1 is clicked with event delegate using addEventListener.跳转2 is clicked with event delegate using onclick.跳转2 is clicked with event delegate using addEventListener. JQuery事件委托在Jquery中还是可以用on方法实现事件代理。123456789101112131415161718192021222324&lt;html !DOCTYPE&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;动态生成的元素绑定事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="J_confirm"&gt;确定&lt;/button&gt; &lt;div id="J_content"&gt;&lt;/div&gt; &lt;script src="https://code.jquery.com/jquery-3.0.0.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $('#J_confirm').on('click',function()&#123; console.log("J_confirm is clicked."); &#125;); $('#J_content').on('click','#J_jump1',function()&#123; console.log($(this).text() + " is clicked with event delegate."); &#125;); $('#J_content').on('click','#J_jump2',function(e)&#123; console.log($(this).text() + " is clicked with event delegate."); &#125;); $('#J_content').append('&lt;button id="J_jump1"&gt;跳转1&lt;/button&gt;'); $('#J_content').append('&lt;button id="J_jump2"&gt;跳转2&lt;/button&gt;'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 所以，动态生成的节点上绑定事件无效，其实是如果事件在dom节点不存在时绑定，才会无效，对于动态生成的节点如果事件是在节点存在之后绑定的，是没有问题的。 参考 JQuery Event Handler Attachment JQuery .on() jQuery API jQuery API 中文文档]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts绘制图形，不同时间段区域颜色不同]]></title>
    <url>%2FECharts%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E6%AE%B5%E5%8C%BA%E5%9F%9F%E9%A2%9C%E8%89%B2%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[ECharts很强大，所以各种配置项和参数也超多，要想画出想要的效果，还真是一个细致活儿。在项目中使用echarts需要先 npm install echarts –save 或者直接下载js文件引入到项目中。可以先在官网上用模拟数据调试好配置项，然后把options直接copy到项目里，刚开始不知道可以在官网上调试，耽误了好多时间。这次画的曲线有一个特点：有促销和无促销的面积区域需要用颜色区分，有促销：橙色，无促销：灰色。 最终效果 代码下面是在ECharts调试的代码，也可以到http://gallery.echartsjs.com/editor.html?c=xHJpzlHKQe查看 按照时间顺序和每天的状态status，将数据分割成多个series,每个series设置不同的areaStyle和itemStyle。 图例的颜色会与itemStyle.normal.color的颜色相同，例如这里有两个图例legend：有促销和无促销，它们的颜色对应series中有相同name的itemStyle.normal.color。 所以如果itemStyle.normal.color要求都是蓝色，图例就不能按需求展示有促销为橙色，无促销为灰色，而是展示的itemStyle.normal.color。 所以其实项目中的图例是我自己画的，并不是用的echarts的legend属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// 数据 status为0表示这一天无促销，为1表示有促销var effectDTOList = [ &#123; "date": "2016-10-30", "salesCnt": 22, "status": 0 &#125;, &#123; "date": "2016-10-31", "salesCnt": 27, "status": 0 &#125;, &#123; "date": "2016-11-01", "salesCnt": 44, "status": 0 &#125;, &#123; "date": "2016-11-02", "salesCnt": 64, "status": 0 &#125;, &#123; "date": "2016-11-03", "salesCnt": 77, "status": 1 &#125;, &#123; "date": "2016-11-04", "salesCnt": 99, "status": 1 &#125;, &#123; "date": "2016-11-05", "salesCnt": 102, "status": 1 &#125;, &#123; "date": "2016-11-06", "salesCnt": 116, "status": 1 &#125;, &#123; "date": "2016-11-07", "salesCnt": 99, "status": 0 &#125;, &#123; "date": "2016-11-08", "salesCnt": 77, "status": 0 &#125;, &#123; "date": "2016-11-09", "salesCnt": 64, "status": 0 &#125;, &#123; "date": "2016-11-10", "salesCnt": 70, "status": 0 &#125; ];//准备数据源和配置项var xAxis = [], //x轴数据 yAxis = [], //y轴数据 data = [], //每个系列（series）图表数据，是个二维数组 series = [], seriesItem;var st = effectDTOList[0].status;for (var i = 0; i &lt; effectDTOList.length; i++) &#123; var date = effectDTOList[i].date.substring(5); xAxis.push(date); yAxis.push(effectDTOList[i].salesCnt); data.push([date, effectDTOList[i].salesCnt]); if (st != effectDTOList[i].status || (i == effectDTOList.length - 1)) &#123; var color = st == 1 ? '#ff8c66' : "#e2e2e2"; var name1 = st == 1 ? '有促销' : "无促销"; seriesItem = &#123; name: name1, type: 'line', smooth: true, symbolSize: 7, //转折点的大小 data: data, areaStyle: &#123; normal: &#123; color: color, opacity: 1 &#125; &#125;, lineStyle: &#123; //曲线样式 normal: &#123; color: '#ff8c66' &#125; &#125;, itemStyle: &#123; //转折点的样式 normal: &#123; color: color, borderWidth: 2, borderType: 'solid' &#125; &#125; &#125;; series.push(seriesItem); data = [ [date, effectDTOList[i].salesCnt] ]; st = effectDTOList[i].status; &#125;&#125;//配置项option = &#123; grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, title: &#123; text: '销售量曲线图', subtext: '不同时间段面积标记不同颜色' &#125;, legend: &#123; right: 50, top: 20, data: [&#123; name: '无促销', icon: 'circle', textStyle: &#123; color: '#333', fontSize: '14' &#125; &#125;, &#123; name: '有促销', icon: 'circle', textStyle: &#123; color: '#333', fontSize: '14' &#125; &#125; ] &#125;, //工具栏 toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; //下载图片 &#125; &#125;, //缩放配置 dataZoom: [&#123; type: 'inside', //内嵌缩放，如鼠标滚轮滚动、两指滑动 xAxisIndex: [0] //x轴可缩放 &#125;], tooltip: &#123; trigger: 'axis', formatter: function(params) &#123; for (let i = 0; i &lt; params.length; i++) &#123; if (params[i].value) &#123; return params[i].value[1]; &#125; &#125; return 'loading'; &#125;, backgroundColor: '#ff6633', padding: [10], axisPointer: &#123; lineStyle: &#123; color: '#ddd' &#125; &#125; &#125;, xAxis: &#123; axisTick: &#123; show: true &#125;, type: 'category', boundaryGap: false, data: xAxis, axisLine: &#123; lineStyle: &#123; color: '#ddd' &#125; &#125;, axisLabel: &#123; textStyle: &#123; color: '#333' &#125; &#125; &#125;, yAxis: &#123; axisTick: &#123; show: false &#125;, type: 'value', axisLine: &#123; show: false &#125;, splitLine: &#123; lineStyle: &#123; color: '#ddd' &#125; &#125; &#125;, series: series&#125;; 参考 ECharts官网 ECharts GitHub]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小桔子]]></title>
    <url>%2F%E5%B0%8F%E6%A1%94%E5%AD%90%2F</url>
    <content type="text"><![CDATA[最近有点忙晕，周末来公司坐坐。平时的周末，一般都是待在家里。早上起床，跟室友聊聊天，吃个饭，看个视频，看看书，睡个觉，一天就这么过去了。偶尔出来，也能发现一些小惊喜。要不，以后都记录下来吧~~同组的姑娘，周末也来了公司，给了一个小桔子。一眼就被萌到了，长得太萌，一个小桔子吃了半个小时。。怎么连桔子都这么美丽@^@]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件]]></title>
    <url>%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在web浏览器中操作页面时，会发生各种不同的事件，比如光标停留，鼠标点击。我们可以使用javascript应用程序关注特定类型的事件，并注册当事件发生时要调用的函数,即事件处理器。事件有几个重要的概念：这几个概念： 事件类型 event type 事件目标 event target 事件处理程序（event handler）或 事件监听程序（event listener） 事件对象：与特定事件相关的，包含该事件详细信息的对象，作为参数传递给事件处理函数。 事件注册和移除设置事件目标的onxxx属性123456&lt;div onclick="clickHandler()"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt;function clickHandler()&#123; console.log("2017，你好。");&#125;&lt;/script&gt; 或者123456&lt;div id="id0"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("id0").onclick = function clickHandler()&#123; console.log("2017，你好。"); &#125;&lt;/script&gt; 这种设置事件处理程序属性的方法适用于所有浏览器的所有常用事件类型，但是对于每个事件目标的每个事件类型最多只有一个处理程序，如果给某一个事件目标的某一个事件类型绑定多个事件处理程序，后面的事件处理程序会覆盖前面的，就是说只会执行最后一个事件处理函数。例如下面的元素id0绑定了两个click事件函数，点击后控制台只会输出 【2016，再见。】123456789&lt;div id="id0"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("id0").onclick = function clickHandler()&#123; console.log("2017，你好。"); &#125; document.getElementById("id0").onclick = function clickHandler()&#123; console.log("2016，再见。"); &#125;&lt;/script&gt; 设置属性的方法注册事件，那移除事件自然是移除onxxx方法。1document.getElementById("id0").removeAttribute("onclick"); addEventListener(eventType,eventHandler,boolean)方法 第一个参数 eventType 注册处理程序的事件类型 第二个参数 eventHandler 事件处理函数 第三个参数 boolean 是一个布尔值，表示是否注册为事件捕获处理函数，默认是false 注：addEventListener的更多用法参见 MDN &gt; Web 技术文档 &gt; Web API 接口 &gt; EventTarget &gt; EventTarget.addEventListener()123456&lt;div id="id0"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("id0").addEventListener("click",function clickHandler()&#123; console.log("2017，你好。"); &#125;);&lt;/script&gt; addEventListener方法在IE9之前的IE浏览器版本不支持，使用的方法是attachEvent()。使用addEventListener可以对同一事件目标的同一事件类型绑定多个处理函数并且一次执行。控制台输出：2017，你好。2016，再见。123456789&lt;div id="id0"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("id0").addEventListener("click",function clickHandler()&#123; console.log("2017，你好。"); &#125;); document.getElementById("id0").addEventListener("click",function clickHandler()&#123; console.log("2016，再见。"); &#125;);&lt;/script&gt; 并且不会修改或影响其他方式注册的事件处理程序，如下还是会打印两条信息123456789&lt;div id="id0"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("id0").addEventListener("click",function clickHandler()&#123; console.log("2016，再见。"); &#125;); document.getElementById("id0").onclick = function clickHandler()&#123; console.log("2017，你好。"); &#125;&lt;/script&gt; 如果使用相同的参数在同一对象上调用，只会注册一次处理程序。如下只会打印一条信息。12345678&lt;div id="id0"&gt;点我&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("id0").addEventListener("click",clickHandler); document.getElementById("id0").addEventListener("click",clickHandler); function clickHandler()&#123; console.log("2016，再见。"); &#125;&lt;/script&gt; 与addEventListener注册事件对应的移除事件的方法是removeEventListener方法，参数与addEventListener方法相同。可见，使用addEventListener可以将事件注册为两种，默认都是冒泡事件处理程序 冒泡事件处理程序 在冒泡阶段调用 捕获事件处理程序 在捕获阶段调用 IE浏览器中的attachEvent和detachEvent方法IE5 ~ IE8 这些版本支持attachEvent和detachEvent方法，与addEventListener和removeEventListener方法类似。但也有几点不同： 只接收两个参数，这也说明IE9版本之前的IE浏览器不支持事件捕获。 第一个参数事件类型带前缀‘on’ 如果使用相同的参数在同一对象上调用，调用次数和注册次数相同。而且调用顺序可能和注册顺序不同。 事件对象调用事件处理程序时，会向其传入一个参数：事件对象event,但在IE8及以前的IE版本中不会传入，需要通过window.event获取事件对象 ,所以获取对象时可以这样写: event || window.event 事件传播如果事件对象是文档或者文档元素，大部分事件会冒泡到DOM树根，再到document对象，再到window对象。有几种特例： focus、blur、srcoll事件不会冒泡； 还有load事件会冒泡到document对象停止，不再冒泡到window对象 事件传播的三个阶段： 事件捕获阶段 依次调用 window对象的捕获处理程序 》 document对象的捕获处理程序 》 body对象的捕获处理程序 》 …（DOM树这条路径上的捕获处理程序）… 》 事件目标父元素的捕获处理程序 目标阶段会触发目标对象上的所有监听器,不管是冒泡还是捕获事件处理程序 事件冒泡阶段 与捕获阶段的调用顺序相反，但调用的是这条路径上注册的冒泡处理程序注： 事件捕获在IE9之前的IE中无法使用，一般用在程序调试或事件取消技术中。 阻止事件传播: event.stopPropagation() IE9之前的IE不支持 阻止事件在其他对象上的传播，在事件目标上的其他事件程序仍然会被调用 适用于捕获阶段、目标对象本身、冒泡阶段 event.stopImmediatePropagation() 部分浏览器支持 阻止事件在其他对象上的传播，在事件目标上的其他事件程序也会被阻止调用 适用于捕获阶段、目标对象本身、冒泡阶段 jquery、YUI提供跨浏览器的stopImmediatePropagation()方法 event.cancelBubble = true IE的事件对象提供 阻止事件在其他对象上的传播 适用于目标对象本身、冒泡阶段 事件代理利用事件冒泡可以实现事件代理，在目标元素的祖先元素上注册事件处理程序，并可以通过事件对象的event.target || event.srcElement获取目标对象。 参考 Javascript权威指南(第六版) 第17章 事件处理 MDN &gt; Web 技术文档 &gt; Web API 接口 &gt; 文档对象模型 (DOM) &gt; 事件及DOM MDN &gt; Web 技术文档 &gt; Web API 接口 &gt; EventTargetEventTarget.addEventListener()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端构建工具Gulp]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gulp%2F</url>
    <content type="text"><![CDATA[安装全局安装 1npm install gulp -g 项目开发安装 1npm install gulp -dev --save 插件安装 1npm install gulp-concat gulp-minify-html gulp-minify-css gulp-rename -dev --save 配置文件在项目根目录下需要创建一个名为gulpfile.js的文件,例如 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var gulp = require('gulp');var minifyHTML = require('gulp-minify-html');var concat = require('gulp-concat');var minifyCSS = require('gulp-minify-css');var rename = require('gulp-rename');var minifyJS = require('gulp-jsmin');var babel = require('gulp-babel');var connect = require('gulp-connect');var open = require('gulp-open');gulp.task('html',function()&#123; gulp.src('./src/html/*.html') .pipe(minifyHTML()) .pipe(gulp.dest('./')) .pipe(connect.reload())&#125;);gulp.task('css',function()&#123; gulp.src('./src/css/*.css') .pipe(concat('style.css')) .pipe((minifyCSS())) .pipe(rename(&#123; suffix : '.min'&#125;)) .pipe(gulp.dest('./assets/')) .pipe(connect.reload())&#125;);gulp.task('js',function()&#123; gulp.src('./src/js/*.js') .pipe(concat('main.js')) .pipe(rename(&#123; suffix : '.min'&#125;)) .pipe(gulp.dest('./assets/')) .pipe(connect.reload())&#125;);gulp.task('babel',function()&#123; gulp.src('./src/exercise/**/*.js') .pipe(babel()) .pipe(gulp.dest('./exercise/')) .pipe(connect.reload())&#125;);gulp.task('watch',function()&#123; gulp.watch('./src/html/*.html',['html']); gulp.watch('./src/css/*.css',['css']); gulp.watch('./src/js/*.js',['js']); gulp.watch('./src/exercise/**/*.js',['babel']);&#125;);gulp.task('connect',function()&#123; connect.server(&#123; root:'./', ip:'127.0.0.0', port:'2000', livereload:true &#125;)&#125;);gulp.task('default',['html','css','js','babel','watch','connect'],function()&#123; gulp.src(__filename) .pipe(open(&#123;uri:'http://localhost:2000'&#125;))&#125;); APIgulp.src(globs)输出符合glob匹配模式的文件，返回Vinyl files的stream,可以pipe到别的文件或插件中。 gulp.dest(path)stream能被pipe进来写入一个文件，文件的上级路径在path下，path下文件的路径根据base路径和相对于base的路径计算，如果文件夹不存在会自动创建。 gulp.task(name,function)定义一个任务，接收两个参数。第一个参数是任务的名字，第二个参数是要做的事情。如： 12345gulp.task('html',function()&#123; gulp.src('./src/html/*.html') .pipe(minifyHTML()) .pipe(gulp.dest('./'))&#125;); 任务的名字叫html,要做的事情就是把./src/html/目录下已.html结尾的文件进行压缩后，放到./目录下。如果要执行多个任务，可以这样定义： 1gulp.task('dev',['html','css','js','babel','watch']，function()&#123;&#125;); 任务dev就是执行任务html，css，js，babel，watchcss，js，babel，watch都要像任务html一样被定义 默认情况下，这些task会以最大的并发数执行 gulp.watch(glob,tasks)监听文件，当文件改动时，做一些事情。 常用插件 gulp-open –打开一个文件 gulp-rename –重命名文件 gulp-replace –替换路径 gulp-rimraf –删除目录 gulp-minify-html –压缩html文件 gulp-minify-css –压缩css文件 gulp-jsmin –压缩js文件 gulp-uglify –压缩javascript文件 gulp-concat –合并文件 gulp-babel –把es6编译成es5 gulp-less –将less文件编译成css文件 gulp-util –gulp插件的工具方法 Gulp插件开发待研究。。。]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prism 轻量级代码语法高亮库]]></title>
    <url>%2FPrism%E8%BD%BB%E9%87%8F%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Prism是一个轻量的、可扩展的代码语法高亮库，根据现代web标准设计。目前有很多网站在用，JavaScript的创始人Brendan Eich的个人博客也是用的Prism。Prism支持很多种语言，并且扩展性很好，它要求代码放在code标签下，code标签可包含在pre标签内。下面是多种写法下的显示效果。 Prism支持多种代码高亮风格，多种语言，并且可以添加插件来丰富Prism的功能。只需要在HTML中引入prism.js和prism.css。 在Prism官网点击下载，依次选择： 是否压缩 选主题，代码风格这里用的okaidia 选语言，按需选择，选择语言越多文件越大 选插件，在prism.js中可以看到每个插件都对应一个立即执行的函数 下载prism.js文件和prism.css文件，引入html文件中12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="./prism.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="language-markup" id="different-markup"&gt; &lt;!--这种写法需要插件File Highlight支持--&gt; &lt;pre data-src="./test.js"&gt;&lt;/pre&gt; &lt;pre class="language-css"&gt;&lt;code&gt;p &#123; color: red; &#125;&lt;/code&gt;&lt;/pre&gt; &lt;pre class="language-css"&gt;&lt;code class="language-*"&gt;p &#123; color: red; &#125;&lt;/code&gt;&lt;/pre&gt; &lt;!--pre和code标签之间有空格ode标签之间，展示出来的效果可以看到代码与边框上下左右间隔不均匀--&gt; &lt;pre class="language-css"&gt; &lt;code class="language-css"&gt;p &#123; color: red; &#125;&lt;/code&gt; &lt;code&gt;p &#123; color: red; &#125;&lt;/code&gt; &lt;/pre&gt; &lt;pre&gt;&lt;code class="language-css"&gt;p &#123; color: red; &#125;&lt;/code&gt;&lt;/pre&gt; &lt;!-- No language, should inherit .language-markup --&gt; &lt;pre&gt;&lt;code&gt;p &#123; color: red; &#125;&lt;/code&gt;&lt;/pre&gt; &lt;code class="language-css"&gt;p &#123; color: red; &#125;&lt;/code&gt; &lt;!-- 没有设置language,会继承父节点的class .language-markup --&gt; &lt;code class="language-*"&gt;p &#123; color: red; &#125;&lt;/code&gt; &lt;!-- 没有高亮 --&gt; &lt;code class="language-none"&gt;p &#123; color: red; &#125;&lt;/code&gt; &lt;/section&gt; &lt;script src="./prism.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 搞定~~ 相关 Prism GitHub Prism官网]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>语法高亮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题中vendors目录下资源找不到报404]]></title>
    <url>%2Fhexo-theme-next%E4%B8%BB%E9%A2%98vendors%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%B5%84%E6%BA%90%E6%89%BE%E4%B8%8D%E5%88%B0%2F</url>
    <content type="text"><![CDATA[昨天发了一篇新文章，部署之后博客都打不开了，两个站点控制台都抛红,NexT主题的source目录下有一个vendors目录，这个目录下的资源文件都无法加载，这是因为github和coding都升级了Jekyll的版本，新版本会忽略vendors文件，github在What’s new in GitHub Pages with Jekyll 3.3中给了解释和解决办法。 to make it easier to vendor third-party dependencies via package managers like Bundler or NPM (or Yarn), Jekyll now ignores the vendor and node_modules directories by default, speeding up build times and avoiding potential errors. If you need those directories included in your site, set exclude: [] in your site’s configuration file. 这里有几个解决办法 把vendors全部手动替换成lib 重新clone主题，NeXT的作者已经修复了这个问题，但是重新clone需要重新设置 项目根目录下新建一个 .nojekyll 隐藏文件 ，内容为!vendor/* 参考： What’s new in GitHub Pages with Jekyll 3.3 关于vendors文件夹里面的js文件和css文件404 Hexo本地预览没问题 deploy后主页空白]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客迁移至GitCafe(Coding)的Pages服务]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3GitCafe%E7%9A%84Pages%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[这个博客之前是挂在GitHub的Pages空间，这两天发现访问博客的速度好慢啊。啊不对，是一直都很慢，这两天是完全打不开了。。。找了找能优化访问速度的办法，最后决定在GitCafe上也部署一个。GitCafe是国内版的GitHub，有了它访问速度真的快好多。国内的支持部署静态博客的代码托管仓库还有Coding，不过打开GitCafe官网发现，它已经被Coding收购了。。。 迁移步骤注册Coding账号用户名要想好，因为无法更改，而且博客的项目名称要跟用户名一致，作为博客网址的一部分。比如用户名是chang20159,项目名是chang20159，博客网址就是http://chang20159.coding.me/ 创建项目并开启Pages服务新建项目很简单，注意项目名最好与用户名一直，至于为什么我也不知道，没研究。。进入项目，在Pages服务中开启Pages服务，并设置分支为master,因为你的项目开发分支是master。这个与你要发布的分支名一直就可以。如果有自己的域名的话，可以将它的cname指向博客地址，并在开启Pages服务后绑定到自己的域名。 编辑Hexo配置文件_config.yml这个跟部署到GitHub是一样的，加上在coding.net上刚创建项目的仓库地址。 deploy: type: git repo: github: git@github.com:chang20159/chang20159.github.io.git coding: git@git.coding.net:chang20159/chang20159.git branch: master 配置SSH如果之前生成过ssh,可以直接使用，存放在~/.ssh/id_rsa.pub这个目录下。打开个人设置-SSH公钥，把id_rsa.pub这个文件里的内容粘贴上去，点击添加就可以了。这一步不做的话，在hexo deploy的时候会提示没有权限，无法部署的。 添加Staticfile文件最后需要在source/目录下放置一个名为Staticfile的文件，coding.net需要这个文件来作为以静态文件部署的标志。如果没有这个文件，打开http://chang20159.coding.me/就会看到**404 page not found**。 cd source/ touch Staticfile #名字必须是Staticfile 这样hexo deploy时就会同时部署到GitHub和Coding.net的Page服务上啦~~~ changdeMacBook-Pro:blog chang$ hexo deploy INFO Deploying: git INFO Clearing .deploy_git folder... INFO Copying files from public folder... On branch master nothing to commit, working directory clean To git@git.coding.net:chang20159/chang20159.git c8979a1..18777cd HEAD -&gt; master Branch master set up to track remote branch master from git@git.coding.net:chang20159/chang20159.git. On branch master nothing to commit, working directory clean To git@github.com:chang20159/chang20159.github.io.git c8979a1..18777cd HEAD -&gt; master Branch master set up to track remote branch master from git@github.com:chang20159/chang20159.github.io.git. INFO Deploy done: git 然后http://chang20159.coding.me/和https://chang20159.github.io/都可以看到新发的内容啦~~~不过，新发布的内容coding上需要等几分钟才会更新。 参考附上一篇写得很好的文章 》》》》》 hexo同时托管到coding.net与github]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作WebIcon字体]]></title>
    <url>%2F%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[字体图标，又名IconFont。在画页面的时候常常会碰到向下的箭头、向上的箭头、向左的箭头、向右的箭头。 额，当然除了箭头还有这样一些东西… 一个页面可能会有很多这种小图标，如果每个图标当用作图片来加载，速度会很慢。像对勾（√）这种简单又有规则的图标，可以用border+rotate画出来，也可以用雪碧图（CSS Sprit），但都没有字体图标扩展性好，而且放大不失真，比较好维护。 要制作想要的字体图标样式，推荐阿里巴巴字体图标库和IcoMoon,下面记录一下我的使用心得。 收集或自己制作SVG格式图标在阿里巴巴字体图标库找到需要的图标并下载，比如我需要一个“加”的图标，像这样点开后可以看到下载图标，点击下载图标进入编辑状态，这时可以选择设置图标的颜色和大小 下面两个图标长得一样，但其实不一样 第一个图标只有一个路径，所以整个图标的颜色只能设置成一样的 第二个图标有两个路径，可以对每个路径分别编辑 设置完成后，点击【SVG下载】如此，收集到想要的SVG格式图标，如果找不到多路径分别设置的图标，也可以自己用SVG编辑器重新设计成多条路径。 Web Icon制作这里制作工具用的IcoMoon App,IcoMoon官网 点击右上角IconMoon App点击左上角图标选择 new empty set,新建一个空集合点击import to set,把刚才下载的svg图标导进来可以看到这些图标有很多都是有颜色的，这些颜色都是在下载的时候设置的全部选中，点击右下角的 generate font,生成字体，又会出来一个编辑页面在这个页面会发现，除了有多条路径的图标颜色还在，其他的图标都是灰色的，只有一条路径的图标其实不用设定颜色，因为设了也没用，这个我们可以在css文件里设置color属性添加颜色。这里可以编辑图标的位置（居中 居右 向左 向下 翻转 镜像等），然后点击Duplicate保存下来 最后一步就是点击右下角的Download,下载一个包，里面有字体文件fonts，和css文件，在项目里引入就好了。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>字体图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6语法简要笔记]]></title>
    <url>%2FES6%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[let和const块级作用域let和const具有块级作用域，只在所在的代码块内有效。12345678//块级作用域var a = [];for(var i = 0; i &lt; 10; i++)&#123; a[i] = function()&#123; console.log(i); &#125;;&#125;a[6](); //10 1234567var b = [];for(let j = 0; j &lt; 10; j++)&#123; b[j] = function()&#123; println(j) &#125;;&#125;b[6](); //6 不存在变量提升let/const不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。123456// 变量提升console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 暂时性死区只要块级作用域内存在let/const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部声明的影响。所以在此区域内的，在声明之前不能使用该变量。1234567//暂时性死区var a = 20159;&#123; a = "chang"; let a ;&#125; 不允许重复声明let/const不允许在相同作用域内，重复声明同一个变量。12345//不允许重复声明&#123; let name; var name;&#125; 字符串模板字符串中嵌入变量123//字符串模板let number = 20159;console.log(`chang $&#123;number&#125;`); 支持多行字符串反斜杠123let idea = `I like to do the front end.How can I do ?`;console.log(idea); 解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值,称为解构赋值。解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。按照此规则可以分为两类：数组的解构和对象的解构。 对象的解构赋值等号左侧是{}，则按右侧数据进行对象解构，此时等号右侧必须是对象或可转为对象的值(undefined和null无法转为对象)。对象的结构根据属性名来匹配。如下，是先找到左侧的同名属性name，再赋给该属性对应的变量name1。最终将profile.name的值付给了name1。如果左侧的属性在对象中没有，对应的变量值将会是undefined,比如sex1234567let profile = &#123; name: "chang", number:20159&#125;;let &#123; name:name1,number:number1,age:age1 = 24,sex:sex1 &#125; = profile;console.log("name1:%s,number1:%d,age1:%d,sex1:%s", name1,number1,age1,sex1);alert(`name1:$&#123;name1&#125;,number1:$&#123;number1&#125;,age1:$&#123;age1&#125;,sex1:$&#123;sex1&#125;`); 如果新的变量名与对象的属性名相同，可以简写成下面这样，等同于 let name = profile.name;1let &#123; name,number,age,sex &#125; = profile; 数组的解构赋值等号的右边的数据结构必须具Iterator接口，等号左边用[]表示1let array = ["ch"] 指定变量的默认值等号左侧是[],则对右侧数据进行数组解构，此时等号右侧必须是具有Iterator结构的值。数组解构根据元素的顺序进行模式匹配。 解构赋值的应用1.交换变量值1[x,y] = [y,x]; 2.提取对象属性1&#123;userInfo,shopInfo&#125; = this.props; 3.解构赋值也可用于函数调用时传参，形参相当于解构等式左侧值，实际传入的参数相当于等式右侧的值。 … 运算符..运算符有两种，spread运算符和rest运算符,作用相反 数组spread运算符spread运算符是将数组或类数组对象展开成一系列用逗号隔开的值12345let array = [1,2,3];let new_array = [...array,4,5]; //数组合并console.log(new_array);let copy_array = [...array]; //数组深拷贝console.log(copy_array); rest运算符将逗号隔开的值序列组合成一个数组123456789//结合数组的解构赋值let [ value,...array ] = [1,2,3,4];console.log(`value:$&#123;value&#125;, array:$&#123;array&#125;`); //value:1, array:2,3,4//用于函数不定长的参数,可避免使用arguments对象var rest = function(...args)&#123;- console.log(`rest.args:$&#123;args[1]&#125;`); //rest.args:es5&#125;;rest("es6","es5","es3"); 对象spread运算符12345let object = &#123;a:1,b:2&#125;;let object1 = &#123;...object&#125;;object1.a = 2;//object1 : &#123;a:2,b:2&#125;//object : &#123;a:1,b:2&#125; rest运算符12345let object = &#123;a:1,b:2&#125;;let &#123;...object2&#125; = &#123;a:1,b:2&#125;;console.dir(object2);//&#123;a:1,b:2&#125; for…of循环for…of可遍历数组的键值，for…in循环只能获得键名123456789101112let array = [10,20,30];array.name = 'es6';//只返回可数字索引的键值 of: 10 of: 20 of: 30for(let value of array)&#123; console.log(`of: $&#123;value&#125;`); &#125; //in: 0 in: 1 in: 2 in: namefor(let value in array)&#123; console.log(`in: $&#123;value&#125;`); &#125; //forEach: 0:10 forEach: 1:20 forEach: 2:30array.forEach(function(item,index)&#123; console.log(`forEach: $&#123;index&#125;:$&#123;item&#125;`); &#125;); Promise对象Promise是一个构造函数，函数的参数是一个未来才会结束的事件，而函数的实例是这个事件执行的状态。简洁的说，Promise对象代表一个异步操作，可以获取异步操作的状态。有三种状态： pending 进行中 resolved 已完成 rejected 已失败 而且状态的改变只会从pending到resolved，或则从pending到rejected注意：Promise一旦new了就会立即执行，无法中断 用法:123456789101112131415var promise = new Promise(function(resolve, reject) &#123; ... if (/* 异步操作成功 */)&#123; resolve(value); //执行resolve函数将状态从Pending变为Resolved &#125; else &#123; reject(error); //执行reject函数将状态从Pending变为rejected &#125;&#125;);／/then方法分别指定Resolved状态和Reject状态的回调函数。promise.then(function(value) &#123; // Resolved状态时执行，value是resolve函数的参数&#125;, function(error) &#123; // rejected状态时执行，value是reject函数的参数&#125;); 实例方法：1、Promise.prototype.then() 为Promise实例添加状态改变时的回调函数2、Promise.prototype.catch() 指定发生错误时的回调函数3、Promise.all() 接收多个Promise实例，返回一个新的Promise实例 如果希望多个请求并发执行，可以使用Promise.all方法 例如：p = new Promise([p1,p2,p3]) 只有p1,p2,p3的状态都是已完成时，p的状态才会变成已完成，并将p1,p2,p3的返回值组成一个数组，传递给p的回调函数； 只要p1,p2,p3有一个失败，p的状态就会变成失败，第一个被reject的实例的返回值，会传递给p的回调函数 注意：p1、p2、p3都是Promise对象的实例，如果不是，就会先调用Promise.resolve方法，将参数转为Promise实例4、Promise.race() 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。率先改变状态的Promise 实例的返回值，传递给p的回调函数。5、Promise.resolve() 返回一个新的 Promise 实例,实例的状态为resolved6、Promise.reject() 返回一个新的 Promise 实例，实例的状态为rejected7、Promise内部的错误不会冒泡到全局，可以通过在回调链尾端添加done方法抛出可能出现的错误1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 抛出一个全局错误 setTimeout(() =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;; 8、finally(callback) 用于指定不管Promise对象最后状态如何，都会执行的操作.接受一个普通的回调函数作为参数，该函数不管怎样都必须执行 Generator函数Generator函数与yield关键字配合可以让代码分布执行，异步操作也是将一个任务分段执行，因此 可以使用Generator函数实现异步编程，拿到第一步的执行结果后再执行第二步，但是程序的写法却跟同步写法一样。看个例子：1234567891011121314function* generator()&#123; let x = 1; let y = yield x+1; let z = yield x + 2; console.log(z);&#125;g = generator();let step1 = g.next()console.dir(step1)let step2 = g.next(step1.value)console.dir(step2)let step3 = g.next(step2.value)console.dir(step3) 结果如下，执行Generator函数返回一个指针对象，调用指针对象的next方法移动指针到yield语句，每次执行都从上一次结束的位置开始。next方法可以传入参数，这个参数是上一个阶段的执行结果。1234567891011121314&gt;Object &gt;done: false &gt;value: 2_ &gt;_proto__: Object&gt;Object &gt;done: false &gt;value: 3_ &gt;_proto__: Object3&gt;Object &gt;done: true &gt;value: undefined &gt;__proto__: Objectundefined Generator函数能够让异步编程可以像写同步执行的代码一样，但是阶段执行的管理却很麻烦，我得知道什么时候执行那一步。有些方法可以让Generator函数自动执行，这里还没研究。 Set和MapSetSet实例是不重复值的集合 Set实例的属性和方法let list = new Set([1,2,2,4]) 属性 size 返回成员数量 操作方法 add(value)：添加某个值，返回的是当前的Set对象，可以采用链式写法 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 注意：WeakSet 结构与 Set 类似，也是不重复的值的集合，但WeakSet的成员只能是对象。并且WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用 MapMap是键值对的集合，“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。 Map实例的属性和方法let map = new Map([[‘name1’,’chang’],[‘name2’,’chen’]]) 属性 size 返回成员数量 操作方法 set(value)：添加键值对，返回的是当前的Map对象，可以采用链式写法 delete(value)：删除某个键，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示某个键是否在当前 Map 对象 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 注意：WeakMap结构与Map结构类似，也是用于生成键值对的集合，但WeakMap只接受对象作为键名（null除外），并且WeakMap的键名所指向的对象，不计入垃圾回收机制。 提示：垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存 类修饰器import和exportES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。模块功能由export和import两个命令完成。export对外输出模块，import用于引入模块。 export 写法import接受一对大括号，指定从其他模块导入的变量名。大括号中的变量名，必须与被导入模块对外接口的名称相同。1234567891011121314151617// 写法一export var value = 1;export function func()&#123;...&#125;;// 写法二var value = 1;function func()&#123;...&#125;;export &#123;value,func&#125;;// 写法三var value = 1;function func()&#123;...&#125;;export &#123; value as value1, func as func1, func as func2&#125;; import写法12345// 写法一import &#123; value, func&#125; from &apos;module&apos;// 写法二import * as Module from &apos;module&apos; export default写法1234export var value = 1;export default function func()&#123;...&#125;;import func, &#123;value&#125; from &apos;module&apos; async 函数其实是Generator函数的语法糖，将Generator函数和自动执行器，包装在一个函数里Generator 函数需要调用next方法，每调一次执行一段。 async函数返回一个Promise 对象，一旦遇到await就会先返回，等到异步操作完成再接着执行函数体内后面的语句。 async函数的返回值，会作为then方法回调函数的参数。 await命令后面是一个Promise 对象。如果不是，会被转成一个立即resolve的Promise 对象。下面代码的执行结果是： 哈哈 嘿嘿 4123456789async function cal(x)&#123; let result = await x + 1; console.log(&apos;嘿嘿&apos;) return result;&#125;cal(3).then(function(data)&#123; console.log(data)&#125;)console.log(&apos;哈哈&apos;) 与Generator 函数相比 async函数内置了执行器，像普通函数一样执行 async和await，比星号和yield语义更清楚。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 async函数的返回值是 Promise 对象 箭头函数12345function func(x,y)&#123; if(x+y &gt; 5)&#123; return x * y &#125;&#125; 有了箭头函数，上面的方法可以写成：12345(x,y) =&gt; &#123; if(x+y &gt; 5)&#123; return x * y &#125;&#125; 如果函数体只有一个return语句，可以将大括号和return省略1(x,y) =&gt; x * y 如果返回的是个对象,得加上（），参数如果只有一个，可以不要()1(name) =&gt; (&#123;name:name&#125;) 箭头函数其实就是一个用箭头简化了的匿名函数，不过与匿名函数有点区别。箭头函数内部的this是词法作用域，由上下文确定，指向函数定义时的上下文。下面的代码，obj.sayHello()得到的结果是undefined,因为this.name指向window或undefined123456789var obj = &#123; name: &apos;chang&apos;, sayHello: function () &#123; var fn = function () &#123; return this.name; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 为了正常执行我们会这样做12345678910var obj = &#123; name: &apos;chang&apos;, sayHello: function () &#123; let _this = this var fn = function () &#123; return _this.name; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 但是有了箭头函数就不需要了,可以写成这样1234567var obj = &#123; name: &apos;chang&apos;, sayHello: function () &#123; var fn = () =&gt; this.name; return fn(); &#125;&#125;; 参考 ECMAScript 6 入门 MDN Promise 深入浅出ES6 Promises/A+]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块管理与打包实践]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%B8%8E%E6%89%93%E5%8C%85%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[关于javascript模块化编程的介绍可以参考阮一峰的Javascript模块化编程系列和webpack中文指南，详细讲述了模块系统的演进以及各种方式的使用方法。看完之后特来实践一下。 原始的JS文件加载来看下在html中用script标签引入js文件的情况 新建一个文件目录 mkdir ScriptTag 进入此目录 cd ScriptTag 在此文件中新建文件 touch index.html 内容如下： &lt;html&gt; &lt;head&gt; &lt;title&gt;webpack&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; printModule1FileName(); printModule2FileName(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 新建module1.js 1234var filename = &quot;module1&quot;;function printModule1FileName()&#123; document.write(`This is $&#123;filename&#125;&lt;br/&gt;`);&#125; 新建module2.js var filename = &quot;module2&quot;; function printModule2FileName(){ document.write(`This is ${filename}&lt;br/&gt;`); } 打开index.html文件，浏览器中显示: This is module2 This is module2 将index.html中引入的js文件交换顺序 &lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt; 此时浏览器中显示： This is module1 This is module1 使用这种方式引入js文件，每个js文件中的变量和方法都暴露在全局作用域下，并按照js文件的引入顺序加载，所以当module1和module2中都有filename这个变量且最后引入module2时，加载完成后的filename最终指向的是module2.js中定义的字符串“module2”。当引入的多个js文件中存在多个相同名字的function，在调用此function是也会造成冲突。 除了全局作用域下容易造成变量冲突这种弊端之外，还有： 当js文件之间存在依赖关系时，必须严格保证加载顺序，被依赖的文件要放在前面。 加载时，浏览器会停止渲染（同步加载），加载文件越多，浏览器响应的时间越长。 注： 这里用到了ES6模板文本特性，我用的chrome,说明chrome是支持ES6的，但不是全部都支持，比如export和import. 使用RequireJS加载模块RequireJS是基于AMD规范实现的，在学习RequireJS之前，先介绍一下CommonJS和AMD这两种模块规范。 CommonJS规范CommonJS是为了解决javascript的作用域问题而定义的模块形式，使每个模块可以在它自身的作用域中执行。规范的主要内容是：必须通过module.exports暴露对外的变量或接口；通过require()方法导入其他模块的的输出到当前模块，并且require模块是同步加载。 用于在服务端解析javacript的Nodejs就是参照CommonJS规范实现的，在浏览器端也有对CommonJS模块规范的实现，比如Browserify。但同步加载 模块的方式不适合在浏览器环境中,因为需要等待所有模块都加载完成才开始渲染页面，响应时间很长。 因而，浏览器端的模块只能采用异步加载，这才有了AMD规范的诞生。 AMD规范AMD(异步模块定义)规范支持在浏览器环境中异步加载模块。RequireJS正是AMD规范的一种实现。 AMD规范的的核心思想：模块的加载不影响在它之后的程序的执行，所有依赖这个模块的语句都定义在一个回调函数中，模块加载完成后，再运行回调函数。 RequireJSRequireJS定义了三个变量：requirejs, require, define.其中requirejs === require 模块的定义：通过define函数定义在闭包中，define函数格式为： define(String id,String[] dependencies,Function|Object factory) id:模块的名字，可选参数 dependencies： 自身依赖的模块列表，这些依赖模块的输出作为factory的参数。可选参数。如果没有指定，则默认的依赖模块为[‘require’,’exports’,’module’] factory: 一个函数或者对象。若是一个函数，该函数的返回值就是模块的输出。 模块的加载：require方法用来加载依赖模块，并执行加载完之后的逻辑，require定义格式为： require(String[] dependencies,Function callback) 下面来画个页面，用RequireJS来解决模块的定义、依赖和加载问题。目录结构如下： . ├── entry.js ├── index.html ├── lib │ └── require.js └── module ├── module1.js └── module2.js 要使用define和require函数定义和加载模块需要引入require.js文件。从RequireJS 官网下载最新版本，放在lib文件下。 其中module1和module2是打印文件名的两个模块，定义如下：module1.js define(function(){ function printModule1FileName(){ document.write(&apos;This is module1&lt;br/&gt;&apos;); } return { filename:&quot;module1&quot;, printModule1FileName:printModule1FileName }; }); module2.js define(function(){ var printModule2FileName = function(){ document.write(&apos;This is module2&lt;br/&gt;&apos;); } return { filename:&quot;module2&quot;, printModule2FileName:printModule2FileName }; }); 在entry.js中导入模块并调用依赖模块中的方法打印文件名 require.config({ path: { module: &apos;./module&apos;, } }); require([&apos;module/module1.js&apos;,&apos;module/module2.js&apos;],function(module1,module2){ document.write(`${module1.filename} and ${module2.filename}&lt;br/&gt;`); module1.printModule1FileName(); module2.printModule2FileName(); }); 在index.html中引入require.js和entry.js &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;RequireJS&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;lib/require.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;entry.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; chrome浏览器打开index.html,显示 module1 and module2 This is module1 This is module2 RequireJS解决了并行加载模块的问题，但因为还有以下弊端 代码书写不太符合常规习惯，模块的引入与代码逻辑掺杂在一起。 只能将js文件作为模块加载。 一个加载依赖多个模块就要并行发出多次HTTP请求，影响网页加载速度。虽然require.js提供了一个优化工具可以将多个模块合并在一个文件中只发出一次请求，但一次加载所有模块也很浪费流量，初始化过程慢。 关于RequireJS可参考： RequireJS 官网 RequireJS 中文网 RequireJS GitHub 这里有很多RequireJS使用demo webpack模块管理webpack可以做到按需异步加载所有资源，除了js文件，图片、样式文件、html、模板库等都可以视作模块加载。当然，webpack本身只能加载js文件，需要借助Loader转换器来完成。 在用RequireJS加载非AMD规范模块前，需要先用require.config()方法定义shim属性，标注依赖模块的输出值和依赖性。webpack则只需要直接require,不管模块形式是CommonJS、AM还是普通的JS文件。 在webpack-demo文件目录下新建文件目录如下： . ├── entry.js ├── index.html └── module ├── module1.js └── module2.js index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;webpack&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; entry.js var printModule1 = require(&apos;./module/module1.js&apos;) var printModule2 = require(&apos;./module/module2.js&apos;) function printEntryFileName(){ printModule1(); printModule2(); } printEntryFileName(); module1.js var filename = &quot;module1&quot;; function printModule1FileName(){ document.write(`This is ${filename}&lt;br/&gt;`); } module.exports = printModule1FileName; html中引入的是bundle.js文件，这个文件是从哪里来的呢？在得到这个文件之前需要先一次安装nodejs和webpack,node安装和升级参见：xxx全局安装webpack npm install webpack -g在webpack目录下执行 webpack entry.js ./dist.bundle.js,命令行会输出如下信息： Hash: 71d45b6722deab7e60ec Version: webpack 1.13.2 Time: 75ms Asset Size Chunks Chunk Names bundle.js 2 kB 0 [emitted] main [0] ./entry.js 192 bytes {0} [built] [1] ./module/module1.js 147 bytes {0} [built] [2] ./module/module2.js 145 bytes {0} [built] 打开index.html文件可以看到输出 This is module1 This is module2 这里涉及到了webpack几个重要的概念：入口(entry)、模块(module)、分块(chunk)Asset这一列是webpack编译输出的文件，bundle.js是入口，在html中通过script标签引入，其他的是被entry依赖的模块，webpack将他们按照依赖顺序进行编号. 若要给输出加一个样式，需要在package.json文件中加入loader转换器依赖。 npm init npm install css-loader style-loader 然后在entry.js中引入css模块，然后重新编译 require(&quot;!style!css!./style/style.css&quot;) var printModule1 = require(&apos;./module/module1.js&apos;) var printModule2 = require(&apos;./module/module2.js&apos;) function printEntryFileName(){ printModule1(); printModule2(); } printEntryFileName(); webpack还可以根据配置文件编译打包，不需要在webpack命令后写参数（输入文件和输出文件），默认情况下会搜索当前目录下webpack.config.js文件，也可以通过 –config来指定配置文件。在webpack-demo文件目录下新增webpack.config.jsvar webpack = require(‘webpack’); module.exports = { entry:&apos;./entry.js&apos;, output: { path: __dirname + &apos;/dist&apos;, filename: &apos;bundle.js&apos; }, module: { loaders:[ { test:/\.css$/,loader:&apos;style!css&apos; } ] } } 在终端运行webpack,会得到跟webpack entry.js ./dist.bundle.js一样的结果。最后的文件目录是这样子的 . ├── dist │ └── bundle.js ├── entry.js ├── index.html ├── module │ ├── module1.js │ └── module2.js ├── package.json ├── style │ └── style.css └── webpack.config.js 当webpack遇见ES6把上面最后的文件目录copy出来放到webpack-es6文件目录中，进入webpack-es6目录下操作。在项目中使用ES6语法需要做一些配置。 .babelrc文件在webpack-demo目录下新建.babelrc，这个是将ES6转码成ES5必须要有的文件。文件中的配置如下： { &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [] } .babelrc文件的配置可以参考Babel 入门教程，如果项目使用的React+ES6，presets中则加入 “react”。 配置webpack.config.js在loaders中加入babel配置 var webpack = require(&apos;webpack&apos;); module.exports = { entry:&apos;./entry.js&apos;, output: { path: __dirname + &apos;/dist&apos;, filename: &apos;bundle.js&apos; }, module: { loaders:[ { test:/\.css$/,loader:&apos;style!css&apos; }, { test: /\.js$/, loader: &apos;babel&apos;, exclude: /node_modules/ } ] } } 这里既然用到了npm install babel babel-loader –save 安装必须的依赖.babelrc这个配置加了之后需要安装规则集 ES2015转码规则 npm install babel-preset-es2015 --save react转码规则 npm install babel-preset-react --save webpack.config.js中加入babel-loader也需要安装，还有最基本的bable模块 npm install babel babel-loader --save 使用ES6语法改造项目module1.js 与 module2.js export function printModule1FileName(filename){ document.getElementById(&apos;module1&apos;).innerHTML = `This is ${filename}` } entry.js import &quot;!style!css!./style/style.css&quot; import * as Module1 from &apos;./module/module1.js&apos; import * as Module2 from &apos;./module/module2.js&apos; class Entry{ constructor(filename1,filename2){ Module1.printModule1FileName(filename1); Module2.printModule2FileName(filename2); } } (() =&gt; new Entry(&quot;es6module1&quot;,&quot;es6module1&quot;))(); 或者这样的entry.js import &quot;!style!css!./style/style.css&quot; import * as Module1 from &apos;./module/module1.js&apos; import * as Module2 from &apos;./module/module2.js&apos; class Entry{ constructor(filename1,filename2){ this.filename1 = filename1; this.filename2 = filename2; } printModuleFileName(){ Module1.printModule1FileName(this.filename1); Module2.printModule2FileName(this.filename2); } } var entry = new Entry(&quot;es6module1&quot;,&quot;es6module2&quot;); entry.printModuleFileName(); 其他的文件内容不变，在webpack-es6目录下执行webpack输出内容： This is es6module1 This is es6module1 最后的目录 . ├── .babelrc ├── dist │ └── bundle.js ├── entry.js ├── index.html ├── module │ ├── module1.js │ └── module2.js ├── package.json ├── style │ └── style.css └── webpack.config.js 关于ES6可参考： ECMAScript 6入门 Babel 入门教程 检测浏览器支持的ES6特性]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>模块化编程</tag>
        <tag>webpack</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种深拷贝方法]]></title>
    <url>%2F%E5%90%84%E7%A7%8D%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ECMAScript有5种简单数据类型（也叫基本数据类型）： Null 、 Undefined 、 Number 、String 、 Boolean还有一种复杂数据类型：对象Object。ECMAScript提供了很多原生的引用类型，如Array、Object、Function.基本数据类型保存在栈内存，引用类型的引用地址保存在栈内存，而引用的值保存在堆内存中。我们常会遇到复制一个值的情况，直接复制一个基本数据类型值，能得到一个副本，栈内存中开辟了新的空间存放，而直接复制一个引用类型值时，会为引用地址开辟一个栈内存存放，但引用的值还是同一块堆内存，新的引用地址和老的引用地址相同都指向这一块堆内存。Object类型和Array类型是在程序计算复制过程最需要注意的，看两个例子。 1234567891011var object = &#123; name: 'chang', age: 25, other: &#123; company: 'dianping', time: '201505' &#125;&#125;var object_new = object; //object赋给object_newobject_new.age = 18; //修改了object_new的agealert(object.age); //18 object的age也变了，因为object和object_new指向的是同一块堆内存 12345//数组也是一样var array = [1,2,3,4];var array_new = array;array.push(5);alert(array_new); //1,2,3,4,5 然而有时候并不希望新的对象和老的对象的值一改变就会互相影响。所以要想办法解决这个问题。 深拷贝实现为了能对数组和对象进行深度复制，需要对他们的属性递归复制，直到属性是基本类型值才直接赋值，这样就需要实现一个深度赋值的函数。 123456789101112131415161718192021222324252627282930function typeOf(data)&#123; var map = &#123; '[object Array]' : 'array', '[object Object]' : 'object', &#125; return map[Object.prototype.toString.call(data)];&#125;function deepClone(data)&#123; var result,i; if(typeOf(data) == 'object')&#123; result = &#123;&#125;; for(i in data)&#123; result[i] = deepClone(data[i]); &#125; return result; &#125;else if(typeOf(data) == 'array')&#123; result = []; for(i=0;i&lt;data.length;i++)&#123; result.push(deepClone(data[i])); &#125; return result; &#125;else&#123; return data; &#125;&#125;var object_new = deepClone(object); object_new.age = 18; alert(object.age); //25 借用JSON方法123456789101112131415161718192021222324252627282930var object = Object.create(&#123; other: &#123; company: 'dianping', time: '201505' &#125;&#125;,&#123; name:&#123; value:'chang', configurable:true, enumerable:true, writable:true &#125;, age:&#123; value: 25, configurable:true, enumerable:true, writable:true &#125;, sayHello:&#123; value: function()&#123;&#125;, configurable:true, enumerable:true, writable:true &#125;&#125;)var temp = JSON.stringify(object);var object_new = JSON.parse(temp);object.age = 18;alert(object_new.age); //25 互不影响 但是这种方法有个缺点，JSON不支持变量、函数或对象实例，在使用JSON.stringify()序列化对象时所有函数及原型成员会被忽略，不体现在结果中。所以object_new中的prototype指向了Object.prototype, sayHello函数也丢失了。 数组深拷贝数组有一些自己的深拷贝方法 spread运算符spread运算符是将数组或类数组对象展开成一系列用逗号隔开的值 1234var array = [1,2,3];var array_new = [...array];array_new.push(4);alert(array); //1,2,3 concat()和slice()Array的concat()方法:先创建当前数组的一个副本，然后将接收到的参数添加到副本的末尾，最后返回新构建的数组。 1234var array = [1,2,3];var array_new = array.concat();array_new.push(4);alert(array); //1,2,3 Array的slice()方法: 可以返回一个新数组，新数组是原数组的一个片段，接收1个或2个参数，第一个参数表示片段在原数组中的起始位置，第二个参数表示片段在原数组中的结束位置，如果第二个参数省略，结束位置在yuan数组的末尾项。 1234var array = [1,2,3];var array_new = array.slice(0); //不带参数与此效果一样array_new.push(4);alert(array); //1,2,3 参考 JavaScript高级程序设计 第3章 基本概念 3.4 数据类型 JavaScript高级程序设计 第5章 引用类型 5.2.6 Array类型 操作方法 JavaScript高级程序设计 第6章 面向对象的程序设计 6.1.3 属性特性 6.3.4 原型式继承 Object.create() JavaScript高级程序设计 第20章 JSON 20.2 解析与序列化]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中方法]]></title>
    <url>%2F%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[水平垂直居中在工作中经常遇见，学习了下CSS布局，顺便总结一些水平垂直居中布局的方法。 少年锦时 利用子元素margin实现居中时要注意: 水平格式化有7个相关属性：margin-left、border-left、padding-left、width、padding-right、border-right、margin-right 垂直格式化也有7个相关属性:margin-top、border-top、padding-top、height、padding-bottom、border-bottom、margin-bottom 在正常流中一个块元素的margin-top和margin-bottom设置为auto时，会自动计算为0； 而将会计元素的margin-left和margin-right设置为auto时，会自动计算为相等的长度； 所以对于定宽的块级元素margin-left:auto;margin-right：auto;可使元素水平居中。 一、单行文本垂直居中利用line-height + text-align123&lt;div class="container"&gt; &lt;span&gt;少年锦时&lt;/span&gt;&lt;/div&gt; 12345678910.container&#123; border: 1px solid #ff6633; color:#ff6633; width: 300px; height:200px; text-align:center;&#125;span&#123; line-height:200px;&#125; 二、padding填充计算父元素与子元素宽高差，设置父元素paddingpaddingLeft = paddingRight = (parent.width - child.width)/2paddingTop = paddingBottom = (parent.height - child.height)/2 123&lt;div class="container"&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415*&#123; box-sizing: border-box; &#125;.container&#123; border: 1px solid #ff6633; color:#fff; width: 300px; height:200px; padding: 50px 0;&#125;.content&#123; width: 100px; height: 100px; background-color:#ff6633;&#125; 三、margin填充123456789101112131415*&#123; box-sizing: border-box; &#125;.container&#123; border: 1px solid #ff6633; color:#fff; width: 300px; height:200px;&#125;.content&#123; width: 100px; height: 100px; background-color:#ff6633; margin: 50px 100px;&#125; 四、absolute布局的水平垂直居中结合position和transform水平移动1234567891011121314151617.container&#123; position: relative; border: 1px solid #ff6633; color:#fff; width: 300px; height:200px; &#125;.content&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); -webkit-transform: translate(-50%,-50%); width: 100px; height: 100px; background-color:#ff6633; &#125; 五、IFC布局上下文的水平垂直居中主要是垂直居中使用vertical-align属性1234&lt;div class="container"&gt; &lt;div class="hidden"&gt;&lt;/div&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.container&#123; border: 1px solid #ff6633; color:#fff; height:200px; text-align: center;&#125;.hidden&#123; width: 0; height: inherit;&#125;.hidden,.content&#123; display: inline-block; vertical-align: middle;&#125;.content&#123; width: 100px; height: 100px; background-color:#ff6633;&#125; 六、table布局上下文下的水平垂直居中将div模拟成表格,利用单元格的vertical-align属性垂直居中，水平居中可以用text-align和margin：auto12345&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.container&#123; display: table; width: 400px; height: 200px; border: 1px solid #ff6633; color:#fff; &#125;.row&#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.col&#123; display: inline-block; width: 100px; height: 100px; background-color:#ff6633;&#125; 七、FFC布局上下文下的水平垂直居中利用flex布局的justify-content和align-items1234567891011121314.container&#123; display: flex; justify-content: center; align-items: center; width: 400px; height: 200px; border: 1px solid #ff6633; color:#fff;&#125;.content&#123; width: 100px; height: 100px; background-color:#ff6633;&#125; 上面的这些方法按css布局分个类能加深一些理解 参考 视觉格式化模型 Visual formatting model]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply和bind函数的polyfill实现]]></title>
    <url>%2Fcall%E3%80%81apply%E5%92%8Cbind%E5%87%BD%E6%95%B0%E7%9A%84polyfill%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[123456789var name = 'chen'var foo = &#123; name: 'chang'&#125;function sayHello(age,sex)&#123; alert(this.name + age + sex);&#125; 这里有一个对象foo，一个函数sayHello，如果直接调用sayHello(),结果是弹出chenundefinedundefined我们希望调用函数sayHello,this能指向foo,通过this.name获得foo.name.Javascript提供了几个改变函数this指向的方法，call、apply和ES5提出的bind.如果我们要寄己实现这些方法的polyfill呢，我们知道作为对象的方法调用，方法内的this是指向对象实例的。如果想让函数的this指向对象foo,可以让sayHello成为foo的属性，但在调用完成后要delete这个属性。 实现中要注意一点： 在非严格模式下使用函数的apply()或call()方法时，第一个参数为null或undefined时，会被转换为全局对象，也就是在浏览器中this指向window 在严格模式下，函数的this值始终是指定的值，也就是说第一个参数指定是null,this就是null。（JavaScript高级程序设计 附录B 严格模式 B.7 抑制this） 那么执行下面代码会报错 1234(function()&#123; 'use strict' sayHello.apply(null,[27,'男'])&#125;)() Uncaught TypeError: Cannot read property 'name' of null 这里都按非严格模式来实现 call函数123456789101112Function.prototype.call_ = function(ctx)&#123; ctx = ctx || window; ctx.fn = this; let args = []; let length = arguments.length; for(let i=1;i&lt;length;i++)&#123; args.push(arguments[i]); &#125; let result = ctx.fn(...args); delete ctx.fn; return result;&#125; 123//调用sayHello.call_(foo,25,'女') //chang25女sayHello.call_(null,27,'男') //chen27男 apply函数12345678Function.prototype.apply_ = function(ctx)&#123; ctx = ctx || window; ctx.fn = this; let args = arguments[1] || []; let result = ctx.fn(...args); delete ctx.fn; return result;&#125; 123//调用sayHello.apply_(foo,[25,'女']) //chang25女sayHello.apply_(null,[27,'男']) //chen27男 bind函数123456789Function.prototype.bind_ = function(ctx)&#123; let _this = this; //this指向Function实例，即调用bind_的函数 let outerArgs = Array.prototype.slice.call_(arguments,1); return function()&#123; let innerArgs = Array.prototype.slice.call_(arguments); let finalArgs = outerArgs.concat(innerArgs); _this.apply_(ctx,finalArgs); &#125;&#125; 123456//调用fn = sayHello.bind_(foo,25);fn('女') //chang25女fn = sayHello.bind_(null,27);fn('男') //chen27男 注意 ctx是要改变的函数内部的执行环境，即this指向 每个函数在被调用时都会自动取得两个特殊变量：this和arguments,内部函数在搜索这两个变量时，只会搜索到其活动对象为止，永远不可能访问到外部函数中的这两个变量。如果想访问作用域链中的this和arguments，必须将他们的对象引用保存在另一个闭包能访问到的变量中。 ES6提供spread运算符 …，可将数组或类数组对象展开成一系列用逗号隔开的值 参考 JavaScript高级程序设计 第5章 引用类型 5.5.4 函数内部属性 this和arguments JavaScript高级程序设计 第5章 引用类型 5.5.5 函数属性和方法 call()和apply() JavaScript高级程序设计 第7章 函数表达式 7.2.2 （闭包）关于this对象） JavaScript高级程序设计 第22章 高级技巧 22.1.4 函数绑定bind()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHub搭建静态博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一直都想有个自己的空间写写东西，现在终于动起来啦~网上找了好久的教程，选择方案也有很多，最后还是觉得基于GitHub，用Hexo来搭建最省事。（ps: 一开始还想自己写个主题来着，后来写哭了。。太费时费力）关于主题的选择也是纠结了很久，一直找不到喜欢的主题，这个博客主题也是无意在一个网友的个人博客看到的，有了喜欢的主题，我才开始搭建这个博客。。。来记录一下博客搭建的过程吧~首先，使用任何有官方的东东都别忘了去官网溜一圈，Hexo官网，还有官方文档和官网提供的主题 这样只能本地查看个人博客安装 hexonpm install hexo-cli -g 新建项目目录blog,并在此目录下初始化hexomkdir blog cd blog hexo init 安装依赖npm install 启动hexohexo server 命令行会有提示，在浏览器地址栏输入http://localhost:4000，就能看到hexo的实例页面。 这样就能让别人看到你的博客GitHub新建项目项目的名字得是这样： chang20159.github.io ，chang20159是github的账号 编辑hexo的配置文件 _config.yml# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:chang20159/chang20159.github.io.git branch: master 注意： type、repo、branch的前面有两个空格，后面的:后面有一个空格 repo的值是上面创建的项目的github仓库地址这样就把项目关联到这个github项目上了。 部署hexo首先要安装git插件，这样才能把本地资源部署到github服务器上 npm install hexo-deployer-git --save 然后执行 hexo deploy 现在可以打开https://chang20159.github.io/，并且别人也可以来访问了。 写博客发布的文章都在soource/_posts目录下，要写一篇文章可以直接在这个目录下新建一个markdown文件，也可以用这个命令 hexo new &quot;使用Hexo+GitHub搭建静态博客&quot; 写好之后保存下来，依次执行下面的命令： hexo clean hexo generate hexo server hexo deploy https://chang20159.github.io/就能看到最新文章。 可以先在本地写好再部署，执行hexo server后，在本地修改是可以实时更新到http://localhost:4000的 更换主题hexo默认的主题是landscape,我使用的主题是hexo-theme-next 下载主题找到喜欢的主题，从github上clone到themes目录下，https://github.com/iissnan/hexo-theme-next 配置主题编辑_config.yml文件 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: hexo-theme-next theme的值设置成主题名，保存后重新部署就好了。hexo-theme-next这个主题功能蛮强大的，现在有三种页面模式，改一个配置相当于换一个主题，只要在主题的配置文件中设置这个字段 # Schemes # scheme: Muse # scheme: Mist scheme: Pisces 它还有很全的配置文档。 hexo-theme-next 作者博客 hexo-theme-next GitHub hexo-theme-next 配置文档 参考文章 静态博客框架之Hexo &amp; Jekyll 从零开始定制hexo主题 手把手教从零开始在GitHub上使用Hexo搭建博客教程(一)-附GitHub注册及配置 手把手教从零开始在GitHub上使用Hexo搭建博客教程(二)-Hexo参数设置 Hexo博客主题推荐 leancloud官网 多说官网]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础笔记]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础很重要，基础很重要，基础很重要，基础很重要，基础很重要，基础很重要，基础很重要，重要的事情要说N遍！ 原始值与对象原始值JavaScript中的原始值有：undefined、null、字符串、数字、布尔值。对象有函数、数组等。对象可以访问自己的属性和方法，原始值也可以访问属性和方法 &gt; var str = &quot;chang&quot;; str.concat(&quot;20159&quot;); &lt; &quot;chang20159&quot; 对象ECMA-262 把对象定义为:“无序属性的集合，其属性可以包含基本值、对象或者函数。每个对象都是基于一个引用类型创建的 对象属性添加属性 profile.age = 100; 删除属性 delete profile.name; 设置属性值 profile.age = 24; 查看属性值 . 点运算符 book.name []运算符 book[‘name’] []括号内必须是字符串或可转为字符串 profile.age; 或 profile[“age”]; 检测属性 in运算符用来检测对象中是否包含属性（自有属性和继承属性） &quot;age&quot; in profile 可以用对象的hasOwnProperty()检测是否自有属性 profile.hasOwnProperty(&quot;age&quot;); profile.hasOwnProperty(&quot;toString&quot;); 注意： 全局范围内定义的属性无法删除 delete运算符只能删除自有属性，不能删除继承属性 属性特性1、数据属性特性 [[Configurable]] 是否可配置 [[Enumerable]] 是否可枚举（for…in） [[Writable]] 是否可修改属性值 [[Value]] 属性的数据值 2、访问器属性特性 [[Configurable]] 是否可配置 [[Enumerable]] 是否可枚举（for…in） [[Get]] 读取属性时调用 [[Set]] 写入属性时调用 相关方法 Object.defineProperty(object,name,{..属性特性}) 设置属性特性 Object.defineProperties(object,{..}) 设置属性特性 Object.getOwnPropertyDescriptor(object,name) 获得自有属性的特性 例: 下面定义了一个对象的属性，p是没有自有属性的，使用Object.defineProperty（）方法后创建了自有属性，x和y是数据属性，z是访问器属性 12345678910var p = Object.defineProperties(&#123;&#125;,&#123; x: &#123; value:1, writable:true,enumerable:true,configurable:true&#125;, y: &#123; value:2, writable:true,enumerable:true,configurable:true&#125;, z: &#123; get: function()&#123; return Math.sqrt(this.x * this.x + this.y * this.y )&#125;, set: function(val)&#123;this.x=val&#125;, enumerable:true, configurable:true &#125;&#125;) 原始值与对象的区别 原始值是不可变的，对象是可修改的。 相同值的原始值和对象相等但不严格相等 对于字符串来说，原始值的数据类型是string,对象的数据类型是object 代码如下: var str1 = &quot;chang&quot;; var str2 = new String(&quot;chang&quot;); console.log(&quot;str1 == str2&quot;,str1 == str2); console.log(&quot;str1 === str2&quot;,str1 === str2); console.log(&quot;typeof str1 :&quot;, typeof str1); console.log(&quot;typeof str2 :&quot;, typeof str2); str1 == str2 true str1 === str2 false typeof str1 : string typeof str2 : object 注: typeof的返回值一般是这些： number,string, boolean,object,function,undefined 基本包装类型ECMAScript提供3个特殊的引用类型： Boolean、Number、String 12var s1 = "some text";var s2 = s1.substring(2); 变量s1是包含一个字符串”some text”，字符串是基本数据类型，为什么在第二行可以调用substring方法？ 执行第二行代码时会做下面几个操作： 创建一个String类型的实例 在实例上调用指定方法 销毁这个实例 相当于： 123var s1 = new String("some text");var s2 = s1.substring(2);s1 = null; 引用类型与基本包装类型的主要区别就是对象的生存期。 new操作符创建的引用类型实例在离开执行环境前一直保存在内存中 自动创建的基本包装类型的对象只存在与一行代码的执行瞬间 例如下面第三行代码是访问不到color属性的，因为在第二行执行结束就已经销毁了实例 123var s1 = &quot;some text&quot;;s1.color = &quot;red&quot;;alert(s1.color); //undefined 单体内置对象内置对象不必显示实例化 Global对象所有在全局作用域中定义的属性和函数，都是Global对象的属性。浏览器实现了承担该角色的window对象。 isNaN() isFinite() parseInt() parseFloat() encodeURI()/encodeURI() 用于对整个URI编码/解码，不会对本身属于URI的特殊字符进行编码/解码， 例如冒号(:)、正斜杠（/ ）、问号(?)、井号(#) encodeURIComponent()/decodeURIComponent() 用于对URI中的某一段编码/解码。一般情况下使用encodeURIComponent()方法要比 encodeURI()多，因为实践中最常见的是对查询字符串参数而不是对基础URL编码 。 eval() 像一个JS解析器。接收一个参数，即要执行的JS字符串 Math对象常用方法： Math.min()、Math.max() Math.ceil() Math.floor() Math.round() Math.random() Math.abs() Math.exp() Math.power() Math.sqrt() Math.random()在随机显示的场景很有用，从某个整数范围内随机取一个值： 1值 = Math.random() * 可能值总数 + 第一个可能的值 函数函数声明与函数表达式解析器在向执行环境加载数据时，会先读取函数声明（函数声明提升），使其在执行任何代码之前可用。 函数表达式必须等解析器执行到它所在的代码行才会被解释执行。 函数内部属性函数内部有两个特殊对象：arguments 和 this arguments一个类数组对象 arguments.callee 是一个指针，指向拥有这个arguments对象的函数。 严格模式下不能访问arguments.callee，会报错。 注意:函数名仅是一个包含指针的变量，在函数内部使用函数名调用自身时，引用函数名不能改变。 arguments.caller ES5定义这个属性，只是为了区分函数的caller属性。 严格模式下访问会报错，非严格模式下这个属性始终是undefined。 arguments.length 参数长度 thisthis引用的是函数执行的环境对象（作用域） 函数属性 name 函数名称 caller 保存调用当前函数的函数的引用。 在函数内部访问方式有两种： 1234567function func()&#123; console.log(arguments.callee.caller)&#125; function func()&#123; console.log(func.caller)&#125; length length属性表示函数接收的命名参数的个数 prototype 对于JS中的引用类型，prototype通常是用于保存实例方法。在创建自定义引用类型及实现继承时，prototype属性很重要。prototype属性有一个唯一属性：constructor，指向拥有此prototype的函数。 函数的方法每个函数都包含3个非继承而来的方法，可用于设置函数体内this对象的值。 apply(this,[array]) call(this,arg1,arg2,…) bind(this，arg1，arg2) 创建一个函数的实例this，this值会绑定到传入的this值。 什么是闭包？每一段Js代码都有一个与之关联的作用域链，对于一个函数，函数定义时的作用域链在函数执行时依然有效，当函数执行时可以访问作用域链上的变量，而且无论这个函数将来在哪里执行都能够访问到函数定义时的作用域链中的变量。 函数的作用域链上除了函数本身的作用域对象之外，有最外层的全局作用域，还可能有外层函数的作用域，这种可以访问另一个函数作用域或全局作用域中的变量的函数就是一个闭包。 从这个角度讲，所有的Javascript函数都是闭包。 闭包的形成可归因于： JS的词法作用域和作用域链。（作用域链上有其他外层函数的作用域，函数可逐层搜索变量） 下面是之前整理的对于闭包的理解，先放着。 理解闭包先得理解词法作用域和作用域链词法作用域函数执行依赖于变量作用域，这个作用域是在函数定义是决定的，不是在函数调用时决定的。为了实现这种词法作用域，javascript函数对象内部不仅包含函数的代码逻辑，还必须引用当前的作用域链作用域链 javascript是基于词法作用域的语言，每一段代码（全局代码或函数）都有一个与之关联的作用域链，这个作用域链是一个对象链表。 在javascript最顶层的代码中，作用域链由一个全局对象组成 在不包含嵌套的函数体内，作用域上有两个对象，第一个是定义函数参数和局部变量的对象,第二个是全局对象 在一个嵌套的函数体内，作用域链上至少有三个对象。 当定义一个函数时，它实际上会保存一个作用域链。 当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至它保存的作用域链上，同时创建一个新的更长的表示函数调用作用域的链 对于嵌套函数，每次调用外部函数时，内部函数又会重新定义一遍，因为每次调用外部函数时作用域链都是不同的。 闭包 由函数和函数定义是的作用域链组成所有的javascript函数都是闭包，闭包就是函数定义时的作用域链在函数执行时依然有效。 根据以上规则，看看下面输出什么 1234567891011121314151617function func()&#123; var count = 0; function cal()&#123; var num= 0 console.log('num',num++) console.log('count',count++ ) ; &#125; return cal;&#125;var func1 = func(); //每次调用func都会创建一个新的作用域链和新的私有变量var func2 = func(); //func1与func2互不影响func()(); //num 0 count 0func()(); //num 0 count 0func1(); //num 0 count 0func1(); //num 0 count 1func2(); //num 0 count 0func2(); //num 0 count 1 javascript是基于词法作用域的，函数的作用域在函数定义时就决定了，如果一个函数内部有一个嵌套函数，并将这个函数返回了，那这个返回的函数韩式可以访问定义时就决定的作用域链，所以这个返回的函数在父函数外部能访问到父函数内部的变量，这样这个函数就形成了一个闭包。 垃圾回收机制 标记清除 JavaScript中最常用的垃圾回收方式，回收被标记的（需要回收的）变量。 垃圾回收器在运行时，给存储在内存中的所有变量都添加标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾回收器消除那些带标记的值并回收内存空间。 目前各大浏览器都是采用标记清除式策略，不过垃圾回收的时间间隔不同。 引用计数 跟踪记录每个值被引用的次数。 如果一个值的被引用次数变成0，说明不能再访问到这个值了，就可以将占用的内存回收。垃圾回收器运行时会释放那些引用次数为0的值所占用的内存。 IE中有一部分对象并不是原生Javascript对象，例如BOM、DOM中的对象是使用C++以COM（组件对象模型）对象的形式实现的。而COM对象的垃圾回收机制采用的是引用计数策略。尽管IE的JS引擎是使用标记清除策略，但JS访问的COM对象依然基于引用计数策略。 当出现循环引用时，引用计数永远不会是0，当被多次调用时，会有大量内存得不到回收，容易造成内存泄漏。在IE中只要涉及COM对象就容易出现循环引用的问题。 例如： 1234var element = document.getElementById("some_element");var myObject = new Object();myObject.element = element;element.someObject = myObject; 导致循环引用的情况不止如此。 为解决此问题，IE9把BOM和DOM对象都转成了真正的Javasript对象，避免了常见的内存泄漏现象。 对象创建对象对象直接量对象原型：Object.prototype 1234let person = &#123; name : 'chang', age : 25&#125; 工厂模式用函数来封装创建特定对象的细节，虽然能解决创建多个相似对象的问题，但不能解决对象识别的问题。 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125;var person1 = createPerson("Nicholas", 29, "Software Engineer");var person2 = createPerson("Greg", 27, "Doctor"); 构造函数模式构造函数模式可以创建特定类型(自定义的构造函数)的对象。 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 注意：构造函数应该以大写字母开头，非构造函数应该以小写字母开头，主要是为了区分。 要创建Person的实例，必须使用new操作符。用这种方式调用构造函数会经历4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象，即this指向这个新对象 执行构造函数中代码，为新对象添加属性 返回新对象 将构造函数当做函数构造函数也是函数，任何函数用new操作符来调用，它就是一个构造函数。不用new操作符调用就是一个普通函数。 12345678910//当做构造函数使用 var person = new Person("Nicholas", 29, "Software Engineer"); person.sayName(); //"Nicholas"//当普通函数调用，在全局环境中调用一个函数时，this对象重视指向Global对象Person("Greg", 27, "Doctor"); //this指向window window.sayName()// 在另一个对象的作用域中调用var o = new Object();Person.call(o, "Kristen", 25, "Nurse"); o.sayName(); //"Kristen" 使用构造函数创建的问题使用构造函数的一个主要问题是： 每个方法在每个实例上都要重新创建一次。我们知道，函数也是对象，在前面的例子中，person1和person2都有一个Function的实例sayName，但person1.sayName != person2.sayName，他们的作用域链不同，标识符解析也不同。 创建两个完成相同功能的Function实例是没有必要的。因而我们可以像这样把方法提出来： 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; alert(this.name);&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 在全局作用域定义方法，这样person1和person2就可以共享一个方法。但是这样所有的方法都得在全局作用域中定义，而且只能给特定对象使用，显然也不合理。 我们可以使用原型模式来解决这个问题 原型模式将属性和方法都添加到构造函数的prototype属性中。 123456789101112131415function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert(person1.name); //"Greg"alert(person2.name); //"Nicholas" delete person1.name;alert(person1.name); //"Nicholas" 原型对象要清楚构造函数、实例和原型对象三者之间的关系。 每个函数都有一个prototype属性，prototype属性是一个指针，指向函数的原型对象 所有原型对象默认都有一个constructor属性，这个属性指向prototype所属的构造函数。 当调用构造函数创建一个新实例后，这个实例内部有一个指针[[Prototype]]指向构造函数的原型对象。 注意： 我们可以通过对象实例访问原型中的值，但不能重写原型中的值。 当为对象实例添加一个属性时，会屏蔽原型中的同名属性。 即使给该属性赋值null也不行，使用delete操作符可以完全删除实例属性 判断是否是原型中的属性123function hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 实例属性与原型属性相关操作符和方法 in 和 for...in 所有能够访问到的属性（实例属性、原型属性） hasOwnProperty() 属性是否存在于实例中 isPrototypeOf() 对象是否是实例的原型对象(实例内部是否有指向该对象的指针) Object.keys() 对象上所有可枚举的实例属性 Object.getOwnPropertyNames() 所有实例属性，无论是否可枚举 Object.getPrototypeOf()获取实例内部[[Prototype]]指针指向的原型对象 重写整个原型对象的问题前面的例子是逐个添加原型对象上的属性和方法，我们也可以直接给prototype对象整个赋值： 12345678910function Person()&#123;&#125;Person.prototype = &#123; name : "Nicholas", age : 29, job: "Software Engineer", sayName : function () &#123; alert(this.name); &#125;&#125;; 但是这样原本Person.prototype中默认的constructor属性就没有了，当访问constructor属性时就是向上访问到Object的constructor属性，指向Object构造函数。 也就是说，这个整体赋值，constructor属性不再是Person构造函数，而是指向Object构造函数。 person1 instanceof Person 还是返回true，但person1.constructor == Object 无法确定对象的类型了。 注意： object instanceof constructor， 用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 设置原型对象constructor属性的问题如果constructor很重要，可以特意设置回原本默认的值： 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor : Person, name : "Nicholas", age : 29, job: "Software Engineer", sayName : function () &#123; alert(this.name); &#125;&#125;; 但是，还是有问题！！这样重设的constructor属性是可枚举的，而默认情况下的原生constructor属性是不可枚举的。 那我们还可以使用 Object.defineProperty()解决这个问题： 12345//只适用于支持ES5的浏览器 Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 使用原型模式创建的问题 省略了为构造函数传递初始化参数这一环节，每个实例默认情况下都有相同的属性值 原型对象是所有实例共享的，这个对于函数非常合适。 对于基本数据类型放在原型中也还没什么问题，因为包含基本值的属性会覆盖原型中的同名属性 但对于引用类型就会有问题，例如： 1234567891011121314151617 function Person()&#123;&#125; Person.prototype = &#123; constructor: Person, name : "Nicholas", age : 29, job : "Software Engineer", friends : ["Shelby", "Court"], sayName : function () &#123; alert(this.name);&#125; &#125;;var person1 = new Person();var person2 = new Person();person1.friends.push("Van");alert(person1.friends); //"Shelby,Court,Van"alert(person2.friends); //"Shelby,Court,Van"alert(person1.friends === person2.friends); //true 组合使用构造函数模式和原型模式创建自定义类型的对象，最常用的方式是组合使用构造函数和原型，也是定义引用类型的一种默认模式。 构造函数模式用于定义实例属性 原型模式用于定义方法和共享的属性 12345678910111213function Person(name, age, job)&#123; this.name = name; 3 this.age = age; this.job = job; this.friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 在上面的例子中，实例属性都在狗在函数中定义，所有实例共享的属性constructor和方法sayName则在原型中定义。 动态原型模式在构造函数中动态初始化原型,在第一次执行构造函数时就完成初始化了 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125; 寄生构造函数模式在上面几种模式都不适用的情况下，可以使用寄生构造函数模式。 基本思想是创建一个函数，这个函数的作用仅仅是封装创建对象的代码。 123456789101112 function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125;var friend = new Person("Nicholas", 29, "Software Engineer");friend.sayName(); //"Nicholas" 注意： 构造函数在不返回值的情况下，默认会返回新的实例。通过在构造函数的末尾添加return语句，可以重写调用构造函数时返回的值。 但是这种方式返回的对象与构造函数以及构造函数的原型之间没有联系。 稳妥构造函数模式没有公共属性，方法也不引用this对象。 12345678function Person(name, age, job)&#123; o.sayName = function()&#123; alert(name); &#125;; return o; &#125;var friend = Person("Nicholas", 29, "Software Engineer");friend.sayName(); //"Nicholas" 与寄生构造函数模式的不同： 新创建的实例方法不引用this 不适用new操作符调用函数 继承ECMAScript是基于原型链继承的 原型链默认的原型原型和实例的关系原型链的问题理解原型链，首先要清楚 构造函数、原型和实例的关系。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 如果这个原型对象是另一个类型的实例，那这个原型对象内部也有一个指针指向另一个原型对象，这样层层递进，就形成了最初那个实例的一个原型链。 注意：所有函数的默认原型都是 Object 的实例，因此默认原 型都会包含一个内部指针，指向 Object.prototype。 实现原型链有一种基本模式 1234567891011121314151617function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue());//true 注意instance.constructor现在指向的是SuperType，因为instance.constructor读取的是instance的原型对象上的constructorinstance的原型对象是SuperType的实例SuperType的实例的constructor指向SuperType所以 instance.constructor指向SuperType 啊 晕不晕 反正我是晕了 最后，原型链有哪些问题？ 123456789function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType()&#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType(); instance1.colors.push(&quot;black&quot;); alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(); alert(instance2.colors); //&quot;red,blue,green,black&quot; 可以看到SubType的原型是SuperType的实例，具有实例属性colors = [“red”, “blue”, “green”]，这是个引用类型值，instance1改变colors的值时也会影响instance2 两个问题：1、原型链中如果包含引用类型值的，当被一个实例修改时，会反应在其他实例上，因为原型的属性是共享的2、在创建子类型的实例时，没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数 因此，实践中很少会单独使用原型链实现继承 借用构造函数（经典继承）在子类型构造函数的内部调用超类型构造函数 123456789101112131415function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType(name)&#123; //继承了 SuperType SuperType.call(this,name);&#125;var instance1 = new SubType(&apos;chang&apos;);instance1.colors.push(&quot;black&quot;); console.log(instance1.name) //changconsole.log(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(&apos;chen&apos;); //changconsole.log(instance2.name)console.log(instance2.colors); //&quot;red,blue,green&quot; 通过使用call()方法或apply()方法，在(未来将要)新创建 SubType 实例的环境下调用了 SuperType 构造函数,让SubType的每个实例就都具有自己的 colors 属性的副本，也解决了原型链中子类型无法给超类型的构造函数传递参数的问题 但是如果只是借用构造函数，所有的超类型都在构造函数中定义，就无法链式继承或复用了。所以一般页不会单独只借用构造函数 原型链和构造函数组合继承将原型链和借用构造函数的技术组合到一块，使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承 原型式继承寄生式继承寄生式组合式继承参考 JavaScript权威指南 JavaScript高级程序设计]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐藏元素的几种方法及应用]]></title>
    <url>%2F%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[隐藏元素的方法有很多，能想到的就有一大摞，像display、opacity、visibility、height、position这些属性都可以达到隐藏元素的效果，但并不是光光把元素隐藏看不见就完事儿了，还得考虑应用场景。整理了几个隐藏元素的方法，以及它们有什么区别，可用于什么样的场景。 这里主要介绍的方法有： display:none; height:0; opacity:0; visibility:hidden; HTML全局属性hidden 像position:absolute;left:-9999px;这样的用法也可以隐藏元素，但我想不到它可以应用的场景，就不讲了。 隐藏元素在隐藏元素之前长这样,后面会将div2隐藏，div2隐藏的后代设置测试株连性（div2隐藏后，div2的后代是否还有可见的机会） div1div2div2的后代 display:none;为什么display:none;可以隐藏元素，看官方文档的解释： display属性：指定建立布局时元素生成的显示框类型 The display property specifies the type of box used for an element. display:none; This value causes an element to not appear in the formatting structure (i.e., in visual media the element generates no boxes and has no effect on layout). Descendant elements do not generate any boxes either; the element and its content are removed from the formatting structure entirely. This behavior cannot be overridden by setting the ‘display’ property on the descendants.Please note that a display of ‘none’ does not create an invisible box; it creates no box at all. CSS includes mechanisms that enable an element to generate boxes in the formatting structure that affect formatting but are not visible themselves. Please consult the section on visibility for details. 这段关于有display:none;的元素的解释有以下几点：1、该元素不会生成box，不占据空间，直接从格式化结构中移除了2、该元素的后代元素也不会生成box，即使给后代元素设置display属性为非none值也没有用3、注意display:none;不是生成一个不可见的box,它根本就没有生成box4、css提供了可以让元素生成一个不可见box的机制，visibility属性就可以实现这个机制 所以display:none;让元素不可见的原因是因为根本就没有生成box,这个元素从格式化结构中移除了 下面设置了div2 display:none; div2的后代 display:block; 但都是不可见的，不占据空间，当然也不会响应交互,div2的后代无法改变不可见状态 div1div2 display:none;div2的后代 display:block; jquery中的hide()、show()、toggle()都是通过控制display:none实现的，使用display:none来隐藏元素会是页面重绘和回流 visibility:hidden;visibility属性：控制由该元素生成的box是否被渲染 The ‘visibility’ property specifies whether the boxes generated by an element are rendered. Invisible boxes still affect layout (set the ‘display’ property to ‘none’ to suppress box generation altogether) visibility:hidden; The generated box is invisible (fully transparent, nothing is drawn), but still affects layout. Furthermore, descendants of the element will be visible if they have ‘visibility: visible’. 这段的解释是：1、生成的box是完全不可见的，完全透明，没有绘制，但不影响布局，仍然占据空间。2、然而这个元素的后代是可以通过设置visibility:visible变成可见的 下面这个就是设置了div2 visibility:hidden; div2的后代设置了 visibility:visible; 并且给div2设置了:hover{visibility:visible; }可见visibility:hidden;使元素隐藏了，但还是占据空间的,把光标放到div2占据的空白处试试看，没有反应说明隐藏后不会响应交互(将光标放在div2的后代上是可以响应交互的)，div2的后代可以设置visibility:visible;改变不可见状态 div1div2 visibility:hidden;div2的后代 visibility:visible; height:0;其实width:0;max-height:0;max-width:0;都可以使元素不可见，一般都用height:0;使用height:0;隐藏元素，不占据空间，也不会响应交互下面设置了div2 height:0;div2的后代 height: 50px;div2的后代可以设置height为非0值改变不可见状态 我是div1，点我看div2div2 height:0div2的后代 height: 50px; opacity:0;opacity设置元素的透明度，当透明度为0时就看不见了，但仍然占据空间。把光标放在div1原本的位置（div2上方的空白处）试试看，opacity:0;是可以响应交互的。div2的后代无法改变不可见状态 div1div2 opacity:0;div2的后代 opacity:1; HTML全局属性hidden这里隐藏了div1，用HTML全局属性hidden隐藏元素不占据空间,div2的后代无法改变不可见状态 div1div2div2的后代 各种方法比较看过每种方法隐藏元素之后的现象，可以从这几个方面来比较，在选择使用哪种方法时也可以参考这几个方面 是否占据空间 是否响应交互 是否触发回流与渲染 是否有株连性 隐藏方法 是否占据空间 是否响应交互 是否触发回流 是否触发重绘 是否有株连性 display:none; 否 否 是 是 是 visibility:hidden; 是 否 否 是 否 height:0; 否 否 是 是 否 opacity:0; 是 是 否 是 是 HTML属性hidden 否 否 是 是 是 参考 opacity visibility display 渲染性能 CSS Triggers]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础]]></title>
    <url>%2FGit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Git是一个版本控制与管理工具。在Mac OS X上可以使用Homebrew安装Git。关于Homebrew的安装参见Homebrew 官网。安装完成后，终端执行brew install git。然后就可以开始使用git啦~~ 文件的三种状态git保存的不是文件差异，而是一系列的文件快照. 在git版本控制系统中，任何一个文件都有三种状态： 已修改(modified) 表明文件被修改，但没有提交保存（工作目录） 已暂存(staged) 表明已修改的文件放在下次提交需要保存的清单中（暂存区域，本质是一个简单的文件） 已提交(committed) 表明该文件已被安全的保存在本地仓库（本地仓库）一个已加入版本控制的文件的工作流：被修改－被暂存－被提交 git clonegit clone [url]从已有的git仓库克隆一个镜像仓库出来，git支持多种数据传输协议 git:// http(s):// ssh://user@server:/path.git表示的SSH传输协议 git clone 本质上就是自动创建了本地的master分支用于跟踪远程的master分支 例： 在当前目录下创建demo目录，也可重新定义新建项目名称，在命令末尾指定新名称mygrit git clone git://github.com/chang20159/demo git-demo git status确定哪些文件当前处于什么状态 例1:当前工作目录很干净，没有任何文件在赏析提交后更改过，也没有处于未跟踪的新文件，当前在alpha分支 On branch alpha Your branch is up-to-date with &apos;origin/alpha&apos;. nothing to commit, working directory clean 例2:新建test.ftl文件，没有修改，会提示有新建文件 On branch alpha Your branch is up-to-date with &apos;origin/alpha&apos;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: apollo-message-center-web/src/main/webapp/WEB-INF/pages/notice/test.ftl 例3:新建test.ftl，并修改，修改后处于未暂存状态，提示使用git add 对未被跟踪的文件跟踪，并将文件快照放入暂存区域。 在Changes to be committed下的都是已暂存状态，在Changes not staged for commit下的都是未暂存状态。若此时提交，则提交的是已暂存的文件，而不是修改后的文件，所以想提交修改后的文件，需要再次使用git add .将修改后的文件提交到暂存区域。 On branch alpha Your branch is up-to-date with &apos;origin/alpha&apos;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: apollo-message-center-web/src/main/webapp/WEB-INF/pages/notice/test.ftl Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: apollo-message-center-web/src/main/webapp/WEB-INF/pages/notice/test.ftl 例4. 对已修改的文件，未提交至暂存区域，红色显示，提示使用git add提交至暂存区域，或者直接使用 git commit -a将已修改但不在暂存区域的文 件一起提交。 changdeMacBook-Pro:apollo-message-center chang$ git status On branch alpha Your branch is up-to-date with &apos;origin/alpha&apos;. Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: apollo-message-center-web/src/main/webapp/WEB-INF/pages/notice/edit-notice.ftl no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) ---------------------我是分割线-------------------------- changdeMacBook-Pro:apollo-message-center chang$ git add . changdeMacBook-Pro:apollo-message-center chang$ git status On branch alpha Your branch is up-to-date with &apos;origin/alpha&apos;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: apollo-message-center-web/src/main/webapp/WEB-INF/pages/notice/edit-notice.ftl git add多功能命令，根据目标文件状态的不同，作用也不同。 跟踪新文件，即将新文件纳入版本控制 将已跟踪的文件放入暂存区 在merge时可将有冲突的文件标记为已解决状态 git diff查看尚未暂存的文件更新了哪些具体内容，比较的是工作目录当前文件与暂存区域快照之间的差异，即修改后还未暂存起来的变化内容。 git diff –cached git 1.6.1及以上版本可使用git diff –staged，作用相同。 查看已暂存文件和上次提交时快照之间的差异 git commit提交到本地仓库，每次提交前需要确定文件是否都已暂存，commit不会纪录还未暂存的数据。 使用git status查看， 将修改过或新建的文件git add。 在git中提交时，会保存一个提交(commit)对象，该对象保存一个指向暂存内容快照的指针。 例1：直接使用git commit 不带参数，提示提交时要加上提交说明，＃号后是附加信息 # Please enter the commit message for your changes. Lines starting # with &apos;#&apos; will be ignored, and an empty message aborts the commit. 例2: 在文件未放入暂存区时，使用git commit -m”test”，提交后git status发现仍然是Changes not staged for commit 因为git commit只提交处于暂存区域的文件，提交前需要git add changdeMacBook-Pro:apollo-message-center chang$ git commit -m&quot;test &quot; [alpha d51853e] test Committer: chang &lt;chang@changdeMacBook-Pro.local&gt; Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly: git config --global user.name &quot;Your Name&quot; git config --global user.email you@example.com After doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 1 file changed, 1 insertion(+), 1 deletion(-) changdeMacBook-Pro:apollo-message-center chang$ git st On branch alpha Your branch is ahead of &apos;origin/alpha&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits) Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: apollo-message-center-web/src/main/webapp/WEB-INF/pages/notice/edit-notice.ftl no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 例3.跳过使用暂存区域 git commit 加上-a参数，git会自动将所有已跟踪的文件暂存起来一并提交，从而跳过git add步骤 使用git commit -am”test”后，提示当前工作目录很干净，可以使用git push changdeMacBook-Pro:apollo-message-center chang$ git commit -am&quot;test&quot; [alpha 545fc8f] test Committer: chang &lt;chang@changdeMacBook-Pro.local&gt; Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly: git config --global user.name &quot;Your Name&quot; git config --global user.email you@example.com After doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 1 file changed, 1 insertion(+), 1 deletion(-) changdeMacBook-Pro:apollo-message-center chang$ git st On branch alpha Your branch is ahead of &apos;origin/alpha&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits) nothing to commit, working directory clean git remote查看当前的远程库，会列出每个远程库的简短名称，克隆一个项目后，至少有一个名为origin的远程库，git默认用origin来标识所克隆的原始仓库。 changdeMacBook-Pro:apollo-message-center chang$ git remote origin git remote -v-v –verbose的缩写，显示对应的克隆地址，若有多个远程仓库，会全部列出 changdeMacBook-Pro:apollo-message-center chang$ git remote -v origin git@code.dpoa.com:tg/apollo-message-center.git (fetch) origin git@code.dpoa.com:tg/apollo-message-center.git (push) git fetch从远程仓库中抓取所有本地仓库还没有的数据到本地，执行命令后，可在本地访问该远程仓库中的所有分支。 若是克隆了一个仓库，会自动将远程仓库归于origin名下 git fetch origin会抓取从上次clone后或者上次fetch后别人push的更新。 注意：fetch命令只是将远端的其他人更新的分支数据拉到本地仓库，并不自动合并到当前工作分支，因而无法在本地编辑该远程仓库中的分支，需要手动合并到当前分支。 git pull若设置了某个分支用于跟踪某个远程仓库的分支，可使用pull抓取数据下来，并将远程分支自动合并到本地仓库的当前分支 git pull相当于 git fetch + git merge git push将本地仓库的数据推送到远程仓库 注意：在推数据之前，远程仓库已有其他人推送了若干更新，推送操作就会被驳回(rejected)，必须先pull到本地，若有conflict，要先解决冲突，再重新commit，重新push。 changdeMacBook-Pro:apollo-message-center chang$ git push To git@code.dpoa.com:tg/apollo-message-center.git ! [rejected] alpha -&gt; alpha (fetch first) error: failed to push some refs to &apos;git@code.dpoa.com:tg/apollo-message-center.git&apos; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &apos;git pull ...&apos;) before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. git branch查看本地分支 changdeMacBook-Pro:apollo-message-center chang$ git branch 20150604_chang_apolloMsgCenter 20150612_chang_edit_notice * alpha master git branch -a查看本地和远程分支 ，可以使用参数 -a 查看 changdeMacBook-Pro:apollo-message-center chang$ git branch -a 20150604_chang_apolloMsgCenter 20150612_chang_edit_notice * alpha master remotes/origin/20150604_merge_branch remotes/origin/20150604_jun_dev remotes/origin/20150604_xu_add_message_DAO remotes/origin/20150604_chang_apolloMsgCenter remotes/origin/20150608_zhao_issue_notice_page remotes/origin/20150609_xu_make_Administrator_UI remotes/origin/20150612_chang_edit_notice remotes/origin/HEAD -&gt; origin/master remotes/origin/alpha remotes/origin/alpha_lightmerge remotes/origin/beta_lightmerge remotes/origin/master remotes/origin/merge_alpha 根据远程分支创建本地分支例如需要对远程分支remotes/origin/merge_alpha工作，需要创建本地分支对其跟踪 git checkout -b merge_alpha origin/merge_alpha 注：从远程分支checkout出来的本地分支，称为跟踪分支(tracking branch)。 根据本地分支创建远程分支在当前分支使用git push ，会自动创建被跟踪的远程分支 git branch新建分支git branch ［branch-name］ 新建分支，新建分支后不会自动切换到这个分支。 查看所有远程分支git branch -r git保存一个HEAD指针，始终指向当前工作的本地分支。 changdeMacBook-Pro:apollo-message-center chang$ git branch -r origin/20150604_merge_branch origin/20150604_jun_dev origin/20150604_xu_add_message_DAO origin/20150604_chang_apolloMsgCenter origin/20150608_zhao_issue_notice_page origin/20150609_xu_make_Administrator_UI origin/20150612_chang_edit_notice origin/HEAD -&gt; origin/master origin/alpha origin/alpha_lightmerge origin/beta_lightmerge origin/master origin/merge_alpha 删除本地分支git branch -d 删除远程分支alphagit push origin/alpha 切换分支git checkout [branch-name]切换分支，切换分支后，HEAD就指向切换后的分支 git checkout -b [branch-name]新建分支并切换到该分支，相当于git branch+git checkout git mergegit merge [branch-name] 将branch-name分支合并到当前分支，branch-name分支可以是本地分支，也可以是远程分支。 合并时可能会遇到冲突，git 会在有冲突的文件中加入标准的冲突解决标记。 例如：当前分支alpha 使用git pull &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.jsp &lt;h1&gt;Tp Message Center Web is running!!!&lt;/h1&gt; ======= &lt;h1&gt;Hello World!&lt;/h1&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/alpha:index.jsp ======= 隔开的上半部分是HEAD中的内容，下半部分是远程alpha分支中的内容。 解决冲突的办法：二者选其一或者整合，根据具体情况选择是删除还是保留。&lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这三行都要删掉 冲突解决后使用git add将冲突文件标记为已解决状态，本质上是将快照放到暂存区。确认冲突都解决后，git commit完成此次合并的提交。 .gitignore文件有些文件不需要进行版本控制，不需要纳入git管理，也不希望总出现在未跟踪文件列表，比如日志文件、编译过程中创建的临时文件等等。 可以创建一个名为.gitignore的文件，列出要忽略的文件模式 .git文件如果需要删除对文件的版本控制，可以直接删除.git文件 参考： http://www.open-open.com/lib/view/open1328069609436.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>